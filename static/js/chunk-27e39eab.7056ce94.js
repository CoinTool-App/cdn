(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-27e39eab"],{"04f0":function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleSumTree=t.ProofStep=t.Leaf=t.Bucket=void 0;const s=r("13ca");class i{constructor(e,t){this.size=BigInt(e),this.hashed=t,this.parent=null,this.left=null,this.right=null}}t.Bucket=i;class n{constructor(e,t,r){this.hashFn=e,this.rng=t.map(e=>BigInt(e)),this.data=r}getBucket(){let t;return t=this.data?this.hashFn(this.data):e.alloc(32),new i(BigInt(this.rng[1])-BigInt(this.rng[0]),t)}}t.Leaf=n;class h{constructor(e,t){this.bucket=e,this.right=t}}t.ProofStep=h;class o extends s.Base{constructor(t,r){super(),this.leaves=t,this.hashFn=r,o.checkConsecutive(t),this.buckets=[];for(const e of t)this.buckets.push(e.getBucket());let s=[];for(const e of this.buckets)s.push(e);while(1!==s.length){const t=[];while(s.length)if(s.length>=2){const r=s.shift(),n=s.shift(),h=r.size+n.size,o=this.hashFn(e.concat([this.sizeToBuffer(r.size),this.bufferify(r.hashed),this.sizeToBuffer(n.size),this.bufferify(n.hashed)])),f=new i(h,o);n.parent=f,r.parent=n.parent,r.right=n,n.left=r,t.push(f)}else t.push(s.shift());s=t}this.root=s[0]}sizeToBuffer(t){const r=e.alloc(8),s=new DataView(r.buffer);return s.setBigInt64(0,BigInt(t),!1),r}static checkConsecutive(e){let t=BigInt(0);for(const r of e){if(r.rng[0]!==t)throw new Error("leaf ranges are invalid");t=BigInt(r.rng[1])}}getProof(e){let t=this.buckets[Number(e)];const r=[];while(t&&t.parent){const e=!!t.right,s=t.right?t.right:t.left;t=t.parent,r.push(new h(s,e))}return r}sum(e){let t=BigInt(0);for(const r of e)t+=BigInt(r);return t}verifyProof(t,r,s){const n=[this.sum(s.filter(e=>!e.right).map(e=>e.bucket.size)),BigInt(t.size)-this.sum(s.filter(e=>e.right).map(e=>e.bucket.size))];if(n[0]!==r.rng[0]||n[1]!==r.rng[1])return!1;let h,o=r.getBucket();for(const f of s)h=f.right?this.hashFn(e.concat([this.sizeToBuffer(o.size),this.bufferify(o.hashed),this.sizeToBuffer(f.bucket.size),this.bufferify(f.bucket.hashed)])):this.hashFn(e.concat([this.sizeToBuffer(f.bucket.size),this.bufferify(f.bucket.hashed),this.sizeToBuffer(o.size),this.bufferify(o.hashed)])),o=new i(BigInt(o.size)+BigInt(f.bucket.size),h);return o.size===t.size&&o.hashed.toString("hex")===t.hashed.toString("hex")}}t.MerkleSumTree=o,"undefined"!==typeof window&&(window.MerkleSumTree=o),t.default=o}).call(this,r("1c35").Buffer)},"13ca":function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Base=void 0;const i=r("1c35"),n=s(r("3452"));class h{print(){h.print(this)}bufferIndexOf(e,t,r=!1){if(r)return this.binarySearch(e,t,i.Buffer.compare);const s=(e,t)=>e.equals(t);return this.linearSearch(e,t,s)}static binarySearch(e,t,r){let s=0,i=e.length-1;while(s<=i){const n=Math.floor((s+i)/2),h=r(e[n],t);if(0===h){for(let s=n-1;s>=0;s--)if(0!==r(e[s],t))return s+1;return 0}h<0?s=n+1:i=n-1}return-1}binarySearch(e,t,r){return h.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let s=0;s<e.length;s++)if(r(e[s],t))return s;return-1}linearSearch(e,t,r){return h.linearSearch(e,t,r)}static bufferify(e){if(!i.Buffer.isBuffer(e)){if("object"===typeof e&&e.words)return i.Buffer.from(e.toString(n.default.enc.Hex),"hex");if(h.isHexString(e))return i.Buffer.from(e.replace(/^0x/,""),"hex");if("string"===typeof e)return i.Buffer.from(e);if("bigint"===typeof e)return i.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return i.Buffer.from(e.buffer);if("number"===typeof e){let t=e.toString();return t.length%2&&(t="0"+t),i.Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return i.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return h.bigNumberify(e)}static bigNumberify(e){if("bigint"===typeof e)return e;if("string"===typeof e)return e.startsWith("0x")&&h.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(i.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return BigInt(e);if("number"===typeof e)return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return"string"===typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e,t=!0){return h.bufferToHex(e,t)}static bufferToHex(e,t=!0){return`${t?"0x":""}${(e||i.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return h.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);return i.Buffer.isBuffer(r)?r:this.isHexString(r)?i.Buffer.from(r.replace("0x",""),"hex"):"string"===typeof r?i.Buffer.from(r):"bigint"===typeof r?i.Buffer.from(t.toString(16),"hex"):ArrayBuffer.isView(r)?i.Buffer.from(r.buffer,r.byteOffset,r.byteLength):i.Buffer.from(e(n.default.enc.Hex.parse(t.toString("hex"))).toString(n.default.enc.Hex),"hex")}}isHexString(e){return h.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map((e,r)=>[e,t[r]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}t.Base=h,t.default=h},"26bf":function(e,t,r){(function(t,r){e.exports=r()})(0,(function(){function e(e,t){var r=t?"└":"├";return r+=e?"─ ":"──┐",r}function t(e,t){var r=[];for(var s in e)e.hasOwnProperty(s)&&(t&&"function"===typeof e[s]||r.push(s));return r}function r(s,i,n,h,o,f,a){var u,l,c="",g=0,p=h.slice(0);if(p.push([i,n])&&h.length>0&&(h.forEach((function(e,t){t>0&&(c+=(e[1]?" ":"│")+"  "),l||e[0]!==i||(l=!0)})),c+=e(s,n)+s,o&&("object"!==typeof i||i instanceof Date)&&(c+=": "+i),l&&(c+=" (circular ref.)"),a(c)),!l&&"object"===typeof i){var d=t(i,f);d.forEach((function(e){u=++g===d.length,r(e,i[e],u,p,o,f,a)}))}}var s={asLines:function(e,t,s,i){var n="function"!==typeof s&&s;r(".",e,!1,[],t,n,i||s)},asTree:function(e,t,s){var i="";return r(".",e,!1,[],t,s,(function(e){i+=e+"\n"})),i}};return s}))},"655a":function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.IncrementalMerkleTree=void 0;const i=s(r("13ca")),n=s(r("26bf"));class h extends i.default{constructor(e,t){if(super(),this.hashFn=e,t.depth&&(this.depth=t.depth),t.arity&&(this.arity=t.arity),this.depth<1)throw new Error("depth must be greater than 0");if(this.arity<1)throw new Error("arity must be greater than 0");const r=[];let s=t.zeroValue;if(this.zeroValue=s,this.zeroes=[],this.depth)for(let i=0;i<this.depth;i++)this.zeroes.push(s),r[i]=[],s=this.hashFn(Array(this.arity).fill(s));this.nodes=r,this.root=s}getRoot(){return this.root}getHexRoot(){return this.bufferToHex(this.bufferify(this.getRoot()))}insert(e){if(this.depth&&this.arity&&this.nodes[0].length>=this.getMaxLeaves())throw new Error("tree is full");let t=e,r=this.nodes[0].length;for(let s=0;s<this.depth;s+=1){const e=r%this.arity,i=r-e,n=i+this.arity,h=[];this.nodes[s][r]=t;for(let t=i;t<n;t+=1)t<this.nodes[s].length?h.push(this.nodes[s][t]):h.push(this.zeroes[s]);t=this.hashFn(h),r=Math.floor(r/this.arity)}this.root=t}delete(e){this.update(e,this.zeroValue)}update(e,t){if(e<0||e>=this.nodes[0].length)throw new Error("out of bounds");let r=t;for(let s=0;s<this.depth;s+=1){const t=e%this.arity,i=e-t,n=i+this.arity,h=[];this.nodes[s][e]=r;for(let e=i;e<n;e+=1)e<this.nodes[s].length?h.push(this.nodes[s][e]):h.push(this.zeroes[s]);r=this.hashFn(h),e=Math.floor(e/this.arity)}this.root=r}getDepth(){return this.depth}getArity(){return this.arity}getMaxLeaves(){return Math.pow(this.depth,this.arity)}indexOf(e){return this.nodes[0].indexOf(e)}getLeaves(){const e=this.copyList(this.nodes[0]),t=this.nodes[0].length;for(let r=t;r<this.getMaxLeaves();r++)e[r]=this.zeroValue;return e}copyList(e){return e.map(e=>BigInt(e))}getLayers(){const e=[];for(const t of this.nodes)e.push(this.copyList(t));if(e[0].length<this.getMaxLeaves()){let t=e[0].length;for(let r=t;r<this.getMaxLeaves();r++)e[0][r]=this.zeroValue;for(let r=0;r<this.depth;r++){const s=t%this.arity,i=t-s,n=i+this.arity;for(let t=i;t<n;t++)t>=e[r].length&&(e[r][t]=this.zeroes[r]);t=Math.floor(t/this.arity)}}return e.push([this.root]),e}getHexLayers(){return this.getLayers().reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(this.bufferify(e)))):e.push(t),e),[])}getLayersAsObject(){const e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(this.bufferify(e),!1))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const n={[e[r][i]]:null};if(t.length){n[e[r][i]]={};const s=t.shift(),h=Object.keys(s)[0];if(n[e[r][i]][h]=s[h],t.length){const s=t.shift(),h=Object.keys(s)[0];n[e[r][i]][h]=s[h]}}s.push(n)}t.push(...s)}return t[0]}computeRoot(){let e,t=this.nodes[0].length;for(let r=0;r<this.depth;r+=1){const s=t%this.arity,i=t-s,n=i+this.arity,h=[];for(let e=i;e<n;e+=1)e<this.nodes[r].length?h.push(this.nodes[r][e]):h.push(this.zeroes[r]);e=this.hashFn(h),t=Math.floor(t/this.arity)}return e}getProof(e){if(e<0||e>=this.nodes[0].length)throw new Error("The leaf does not exist in this tree");const t=[],r=[],s=e;for(let i=0;i<this.depth;i+=1){const s=e%this.arity,n=e-s,h=n+this.arity;r[i]=s,t[i]=[];for(let r=n;r<h;r+=1)r!==e&&(r<this.nodes[i].length?t[i].push(this.nodes[i][r]):t[i].push(this.zeroes[i]));e=Math.floor(e/this.arity)}return{root:this.root,leaf:this.nodes[0][s],pathIndices:r,siblings:t}}verify(e){let t=e.leaf;for(let r=0;r<e.siblings.length;r+=1){const s=e.siblings[r].slice();s.splice(e.pathIndices[r],0,t),t=this.hashFn(s)}return e.root===t}toString(){return this.toTreeString()}toTreeString(){const e=this.getLayersAsObject();return n.default.asTree(e,!0)}}t.IncrementalMerkleTree=h,"undefined"!==typeof window&&(window.IncrementalMerkleTree=h),t.default=h},"6d46":function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleTree=void 0;const i=r("1c35"),n=s(r("feaa")),h=s(r("94f8")),o=s(r("26bf")),f=s(r("13ca"));class a extends f.default{constructor(e,t=h.default,r={}){if(super(),this.duplicateOdd=!1,this.concatenator=i.Buffer.concat,this.hashLeaves=!1,this.isBitcoinTree=!1,this.leaves=[],this.layers=[],this.sortLeaves=!1,this.sortPairs=!1,this.sort=!1,this.fillDefaultHash=null,this.complete=!1,r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"===typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!i.Buffer.isBuffer(r.fillDefaultHash)&&"string"!==typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e,t;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:null!==(t=null===(e=this.fillDefaultHash)||void 0===e?void 0:e.toString())&&void 0!==t?t:null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(i.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){this.layers=[e];while(e.length>1){const t=this.layers.length;this.layers.push([]);const r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-Math.pow(2,Math.ceil(Math.log2(e.length))):e.length;for(let s=0;s<e.length;s+=2){if(s>=r){this.layers[t].push(...e.slice(r));break}if(s+1===e.length&&e.length%2===1){const r=e[e.length-1];let i=r;if(this.isBitcoinTree){i=this.hashFn(this.concatenator([n.default(r),n.default(r)])),i=n.default(this.hashFn(i)),this.layers[t].push(i);continue}if(!this.duplicateOdd){this.layers[t].push(e[s]);continue}}const h=e[s],o=s+1===e.length?h:e[s+1];let f=null;f=this.isBitcoinTree?[n.default(h),n.default(o)]:[h,o],this.sortPairs&&f.sort(i.Buffer.compare);let a=this.hashFn(this.concatenator(f));this.isBitcoinTree&&(a=n.default(this.hashFn(a))),this.layers[t].push(a)}e=this.layers[t]}}addLeaf(e,t=!1){t&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e,t=!1){t&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(i.Buffer.compare))),this.leaves.filter(t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?i.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){const s=t[r];if(s.equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(e=>a.bufferToHex(e)),null,2)}static unmarshalLeaves(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(a.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(e))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e),[]);return e.unshift(i.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?i.Buffer.from([]):this.layers[this.layers.length-1][0]||i.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if("undefined"===typeof e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===i.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let s=0;s<this.layers.length;s++){const e=this.layers[s],i=t%2,n=i?t-1:this.isBitcoinTree&&t===e.length-1&&s<this.layers.length-1?t:t+1;n<e.length&&r.push({position:i?"left":"right",data:e[n]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(e=>this.bufferToHex(e.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,r,s){const i=t%2;if(-1===e)return void(i||s.push([...r].reverse()));if(t>=this.layers[e].length)return;const n=this.layers[e],h=i?t-1:t+1;let o=!1;h<n.length&&(o=!0,r.push({position:i?"left":"right",data:n[h]}));const f=2*t,a=2*t+1;this.getProofsDFS(e-1,f,r,s),this.getProofsDFS(e-1,a,r,s),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(e=>["left"===e.position?0:1,this.bufferToHex(e.data)])}static marshalProof(e){const t=e.map(e=>"string"===typeof e?e:i.Buffer.isBuffer(e)?a.bufferToHex(e):{position:e.position,data:a.bufferToHex(e.data)});return JSON.stringify(t,null,2)}static unmarshalProof(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(e=>{if("string"===typeof e)return a.bufferify(e);if(e instanceof Object)return{position:e.position,data:a.bufferify(e.data)};throw new Error("Expected item to be of type string or object")})}static marshalTree(e){const t=e.getHexRoot(),r=e.leaves.map(e=>a.bufferToHex(e)),s=e.getHexLayers(),i=e.getOptions();return JSON.stringify({options:i,root:t,layers:s,leaves:r},null,2)}static unmarshalTree(e,t=h.default,r={}){let s=null;if("string"===typeof e)s=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");s=e}if(!s)throw new Error("could not parse json");return r=Object.assign({},s.options||{},r),new a(s.leaves,t,r)}getProofIndices(e,t){const r=Math.pow(2,t);let s=new Set;for(const f of e){let e=r+f;while(e>1)s.add(1^e),e=e/2|0}const i=e.map(e=>r+e),n=Array.from(s).sort((e,t)=>e-t).reverse();s=i.concat(n);const h=new Set,o=[];for(let f of s)if(!h.has(f)){o.push(f);while(f>1){if(h.add(f),!h.has(1^f))break;f=f/2|0}}return o.filter(t=>!e.includes(t-r))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),s=[];for(let h=0;h<r;h++){const e=t%2!==0;e&&s.push({index:h,leavesCount:t}),t=Math.ceil(t/2)}const i=[];let n=e;for(let h=0;h<r;h++){const e=n.map(e=>e%2===0?e+1:e-1);let t=e.filter(e=>!n.includes(e));const r=s.find(({index:e})=>e===h);r&&n.includes(r.leavesCount-1)&&(t=t.slice(0,-1)),i.push(t),n=[...new Set(n.map(e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2))]}return i}getMultiProof(e,t){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat());const r=this.isUnevenTree();if(r&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(i.Buffer.compare));let r=e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1);if(!r.every(e=>-1!==e))throw new Error("Element does not exist in Merkle tree");const s=[],n=[];let h=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const i=r[t],o=this.getPairNode(e,i);s.push(e[i]),o&&n.push(o),h.push(i/2|0)}r=h.filter((e,t,r)=>r.indexOf(e)===t),h=[]}return n.filter(e=>!s.includes(e))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(t=>e[t])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],s=t;for(const i of e){const e=[];for(const r of s){if(r%2===0){const t=r+1;if(!s.includes(t)&&i[t]){e.push(i[t]);continue}}const t=r-1;s.includes(t)||!i[t]||e.push(i[t])}r=r.concat(e);const t=new Set;for(const r of s)r%2!==0?r%2!==0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);s=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(e=>this.bufferToHex(e))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?[...e].sort((e,t)=>e===t?0:e>t?1:-1):e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1),!r.every(e=>-1!==e))throw new Error("Element does not exist in Merkle tree");const s=t.map(e=>this.bufferify(e)),i=[],n=[];for(let h=0;h<this.layers.length;h++){const e=this.layers[h];r=r.reduce((t,r)=>{const h=i.includes(e[r]);if(!h){const t=this.getPairNode(e,r),h=s.includes(e[r])||s.includes(t);t&&n.push(!h),i.push(e[r]),i.push(t)}return t.push(r/2|0),t},[])}return n}verify(e,t,r){let s=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let h=0;h<e.length;h++){const t=e[h];let r=null,o=null;if("string"===typeof t)r=this.bufferify(t),o=!0;else if(Array.isArray(t))o=0===t[0],r=this.bufferify(t[1]);else if(i.Buffer.isBuffer(t))r=t,o=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),o="left"===t.position}const f=[];this.isBitcoinTree?(f.push(n.default(s)),f[o?"unshift":"push"](n.default(r)),s=this.hashFn(this.concatenator(f)),s=n.default(this.hashFn(s))):this.sortPairs?-1===i.Buffer.compare(s,r)?(f.push(s,r),s=this.hashFn(this.concatenator(f))):(f.push(r,s),s=this.hashFn(this.concatenator(f))):(f.push(s),f[o?"unshift":"push"](r),s=this.hashFn(this.concatenator(f)))}return 0===i.Buffer.compare(s,r)}verifyMultiProof(e,t,r,s,n){const h=this.isUnevenTree();if(h)return this.verifyMultiProofForUnevenTree(e,t,r,s,n);const o=Math.ceil(Math.log2(s));e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),n=n.map(e=>this.bufferify(e));const f={};for(const[i,l]of this.zip(t,r))f[Math.pow(2,o)+i]=l;for(const[i,l]of this.zip(this.getProofIndices(t,o),n))f[i]=l;let a=Object.keys(f).map(e=>+e).sort((e,t)=>e-t);a=a.slice(0,a.length-1);let u=0;while(u<a.length){const e=a[u];if(e>=2&&{}.hasOwnProperty.call(f,1^e)){let t=[f[e-e%2],f[e-e%2+1]];this.sortPairs&&(t=t.sort(i.Buffer.compare));const r=t[1]?this.hashFn(this.concatenator(t)):t[0];f[e/2|0]=r,a.push(e/2|0)}u+=1}return!t.length||{}.hasOwnProperty.call(f,1)&&f[1].equals(e)}verifyMultiProofWithFlags(e,t,r,s){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const n=t.length,h=s.length,o=[];let f=0,a=0,u=0;for(let l=0;l<h;l++){const e=s[l]?f<n?t[f++]:o[a++]:r[u++],h=f<n?t[f++]:o[a++],c=[e,h].sort(i.Buffer.compare);o[l]=this.hashFn(this.concatenator(c))}return 0===i.Buffer.compare(o[h-1],e)}verifyMultiProofForUnevenTree(e,t,r,s,i){e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),i=i.map(e=>this.bufferify(e));const n=this.calculateRootForUnevenTree(t,r,s,i);return e.equals(n)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(e,!1))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const n={[e[r][i]]:null};if(t.length){n[e[r][i]]={};const s=t.shift(),h=Object.keys(s)[0];if(n[e[r][i]][h]=s[h],t.length){const s=t.shift(),h=Object.keys(s)[0];n[e[r][i]][h]=s[h]}}s.push(n)}t.push(...s)}return t[0]}static verify(e,t,r,s=h.default,i={}){const n=new a([],s,i);return n.verify(e,t,r)}static getMultiProof(e,t){const r=new a([]);return r.getMultiProof(e,t)}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return o.default.asTree(e,!0)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(null===e||void 0===e?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,s){const i=this.zip(e,t).sort(([e],[t])=>e-t),n=i.map(([e])=>e),h=this.getProofIndicesForUnevenTree(n,r);let o=0;const f=[];for(let u=0;u<h.length;u++){const e=h[u],t=o;o+=e.length,f[u]=this.zip(e,s.slice(t,o))}const a=[i];for(let u=0;u<f.length;u++){const e=f[u].concat(a[u]).sort(([e],[t])=>e-t).map(([,e])=>e),t=a[u].map(([e])=>e),r=[...new Set(t.map(e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2))],s=[];for(let i=0;i<r.length;i++){const t=r[i],n=e[2*i],h=e[2*i+1],o=h?this.hashFn(this.concatenator([n,h])):n;s.push([t,o])}a.push(s)}return a[a.length-1][0][1]}}t.MerkleTree=a,"undefined"!==typeof window&&(window.MerkleTree=a),t.default=a},b2ed:function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleMountainRange=void 0;const i=r("1c35"),n=s(r("94f8")),h=s(r("13ca"));class o extends h.default{constructor(e=n.default,t=[],r,s,h){super(),this.root=i.Buffer.alloc(0),this.size=0,this.width=0,this.hashes={},this.data={},t=t.map(this.bufferify),this.hashFn=this.bufferifyFn(e),this.hashLeafFn=r,this.peakBaggingFn=s,this.hashBranchFn=h;for(const i of t)this.append(i)}append(e){e=this.bufferify(e);const t=this.hashFn(e),r=this.bufferToHex(t);this.data[r]&&this.bufferToHex(this.hashFn(this.data[r]))===r||(this.data[r]=e);const s=this.hashLeaf(this.size+1,t);this.hashes[this.size+1]=s,this.width+=1;const i=this.getPeakIndexes(this.width);this.size=this.getSize(this.width);const n=[];for(let h=0;h<i.length;h++)n[h]=this._getOrCreateNode(i[h]);this.root=this.peakBagging(this.width,n)}hashLeaf(e,t){return t=this.bufferify(t),this.hashLeafFn?this.bufferify(this.hashLeafFn(e,t)):this.hashFn(i.Buffer.concat([this.bufferify(e),t]))}hashBranch(e,t,r){return this.hashBranchFn?this.bufferify(this.hashBranchFn(e,t,r)):this.hashFn(i.Buffer.concat([this.bufferify(e),this.bufferify(t),this.bufferify(r)]))}getPeaks(){const e=this.getPeakIndexes(this.width),t=[];for(let r=0;r<e.length;r++)t[r]=this.hashes[e[r]];return t}getLeafIndex(e){return e%2===1?this.getSize(e):this.getSize(e-1)+1}getPeakIndexes(e){const t=this.numOfPeaks(e),r=[];let s=0,i=0;for(let n=255;n>0;n--)if(0!==(e&1<<n-1)&&(i=i+(1<<n)-1,r[s++]=i,r.length>=t))break;if(s!==r.length)throw new Error("invalid bit calculation");return r}numOfPeaks(e){let t=e,r=0;while(t>0)t%2===1&&r++,t>>=1;return r}peakBagging(e,t){const r=this.getSize(e);if(this.numOfPeaks(e)!==t.length)throw new Error("received invalid number of peaks");return 0!==e||t.length?this.peakBaggingFn?this.bufferify(this.peakBaggingFn(r,t)):this.hashFn(i.Buffer.concat([this.bufferify(r),...t.map(this.bufferify)])):i.Buffer.alloc(0)}getSize(e){return(e<<1)-this.numOfPeaks(e)}getRoot(){return this.root}getHexRoot(){return this.bufferToHex(this.getRoot())}getNode(e){return this.hashes[e]}mountainHeight(e){let t=1;while(1<<t<=e+t)t++;return t-1}heightAt(e){let t=e,r=0,s=0;while(t>r)t-=(1<<s)-1,s=this.mountainHeight(t),r=(1<<s)-1;return s-(r-t)}isLeaf(e){return 1===this.heightAt(e)}getChildren(e){const t=e-(1<<this.heightAt(e)-1),r=e-1;if(t===r)throw new Error("not a parent");return[t,r]}getMerkleProof(e){if(e>this.size)throw new Error("out of range");if(!this.isLeaf(e))throw new Error("not a leaf");const t=this.root,r=this.width,s=this.getPeakIndexes(this.width),i=[];let n=0;for(let u=0;u<s.length;u++)i[u]=this.hashes[s[u]],s[u]>=e&&0===n&&(n=s[u]);let h=0,o=0,f=this.heightAt(n);const a=[];while(n!==e)f--,[h,o]=this.getChildren(n),n=e<=h?h:o,a[f-1]=this.hashes[e<=h?o:h];return{root:t,width:r,peakBagging:i,siblings:a}}verify(e,t,r,s,i,n){s=this.bufferify(s);const h=this.getSize(t);if(h<r)throw new Error("index is out of range");if(!e.equals(this.peakBagging(t,i)))throw new Error("invalid root hash from the peaks");let o,f=0;const a=this.getPeakIndexes(t);for(let d=0;d<a.length;d++)if(a[d]>=r){o=i[d],f=a[d];break}if(!o)throw new Error("target not found");let u=n.length+1;const l=new Array(u);let c,g=0,p=0;while(u>0){if(l[--u]=f,f===r)break;[g,p]=this.getChildren(f),f=r>g?p:g}while(u<l.length)f=l[u],c=0===u?this.hashLeaf(f,this.hashFn(s)):f-1===l[u-1]?this.hashBranch(f,n[u-1],c):this.hashBranch(f,c,n[u-1]),u++;if(!c.equals(o))throw new Error("hashed peak is invalid");return!0}peaksToPeakMap(e,t){const r={};let s=0,i=0,n=t.length;for(let h=1;h<=32;h++)s=32-h,i=1<<h-1,r[s]=0!==(e&i)?t[--n]:0;if(0!==n)throw new Error("invalid number of peaks");return r}peakMapToPeaks(e,t){const r=this.numOfPeaks(e),s=new Array(r);let i=0;for(let n=0;n<32;n++)0!==t[n]&&(s[i++]=t[n]);if(i!==r)throw new Error("invalid number of peaks");return s}peakUpdate(e,t,r){const s={},i=e+1;let n=this.getLeafIndex(i),h=this.hashLeaf(n,r),o=0,f=0,a=!1,u=!1,l=!1;for(let c=1;c<=32;c++)o=32-c,l?s[o]=t[o]:(f=1<<c-1,a=0!==(e&f),u=0!==(i&f),n++,a&&(h=this.hashBranch(n,t[o],h)),u?(s[o]=a?t[o]:h,l=!0):s[o]=0);return s}rollUp(e,t,r,s){if(!e.equals(this.peakBagging(t,r)))throw new Error("invalid root hash from the peaks");let i=t,n=this.peaksToPeakMap(t,r);for(let h=0;h<s.length;h++)n=this.peakUpdate(i,n,s[h]),i++;return this.peakBagging(i,this.peakMapToPeaks(i,n))}_getOrCreateNode(e){if(e>this.size)throw new Error("out of range");if(!this.hashes[e]){const[t,r]=this.getChildren(e),s=this._getOrCreateNode(t),i=this._getOrCreateNode(r);this.hashes[e]=this.hashBranch(e,s,i)}return this.hashes[e]}}t.MerkleMountainRange=o,"undefined"!==typeof window&&(window.MerkleMountainRange=o),t.default=o},db6e:function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleTree=void 0;const i=s(r("6d46"));t.MerkleTree=i.default;var n=r("b2ed");Object.defineProperty(t,"MerkleMountainRange",{enumerable:!0,get:function(){return n.MerkleMountainRange}});var h=r("655a");Object.defineProperty(t,"IncrementalMerkleTree",{enumerable:!0,get:function(){return h.IncrementalMerkleTree}});var o=r("04f0");Object.defineProperty(t,"MerkleSumTree",{enumerable:!0,get:function(){return o.MerkleSumTree}}),t.default=i.default},feaa:function(e,t,r){(function(t){e.exports=function(e){for(var r=new t(e.length),s=0,i=e.length-1;s<=i;++s,--i)r[s]=e[i],r[i]=e[s];return r}}).call(this,r("1c35").Buffer)}}]);