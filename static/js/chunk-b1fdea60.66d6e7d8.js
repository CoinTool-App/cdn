(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-b1fdea60"],{"04f0":function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleSumTree=t.ProofStep=t.Leaf=t.Bucket=void 0;const s=r("13ca");class i{constructor(e,t){this.size=BigInt(e),this.hashed=t,this.parent=null,this.left=null,this.right=null}}t.Bucket=i;class n{constructor(e,t,r){this.hashFn=e,this.rng=t.map(e=>BigInt(e)),this.data=r}getBucket(){let t;return t=this.data?this.hashFn(this.data):e.alloc(32),new i(BigInt(this.rng[1])-BigInt(this.rng[0]),t)}}t.Leaf=n;class o{constructor(e,t){this.bucket=e,this.right=t}}t.ProofStep=o;class h extends s.Base{constructor(t,r){super(),this.leaves=t,this.hashFn=r,h.checkConsecutive(t),this.buckets=[];for(const e of t)this.buckets.push(e.getBucket());let s=[];for(const e of this.buckets)s.push(e);while(1!==s.length){const t=[];while(s.length)if(s.length>=2){const r=s.shift(),n=s.shift(),o=r.size+n.size,h=this.hashFn(e.concat([this.sizeToBuffer(r.size),this.bufferify(r.hashed),this.sizeToBuffer(n.size),this.bufferify(n.hashed)])),f=new i(o,h);n.parent=f,r.parent=n.parent,r.right=n,n.left=r,t.push(f)}else t.push(s.shift());s=t}this.root=s[0]}sizeToBuffer(t){const r=e.alloc(8),s=new DataView(r.buffer);return s.setBigInt64(0,BigInt(t),!1),r}static checkConsecutive(e){let t=BigInt(0);for(const r of e){if(r.rng[0]!==t)throw new Error("leaf ranges are invalid");t=BigInt(r.rng[1])}}getProof(e){let t=this.buckets[Number(e)];const r=[];while(t&&t.parent){const e=!!t.right,s=t.right?t.right:t.left;t=t.parent,r.push(new o(s,e))}return r}sum(e){let t=BigInt(0);for(const r of e)t+=BigInt(r);return t}verifyProof(t,r,s){const n=[this.sum(s.filter(e=>!e.right).map(e=>e.bucket.size)),BigInt(t.size)-this.sum(s.filter(e=>e.right).map(e=>e.bucket.size))];if(n[0]!==r.rng[0]||n[1]!==r.rng[1])return!1;let o,h=r.getBucket();for(const f of s)o=f.right?this.hashFn(e.concat([this.sizeToBuffer(h.size),this.bufferify(h.hashed),this.sizeToBuffer(f.bucket.size),this.bufferify(f.bucket.hashed)])):this.hashFn(e.concat([this.sizeToBuffer(f.bucket.size),this.bufferify(f.bucket.hashed),this.sizeToBuffer(h.size),this.bufferify(h.hashed)])),h=new i(BigInt(h.size)+BigInt(f.bucket.size),o);return h.size===t.size&&h.hashed.toString("hex")===t.hashed.toString("hex")}}t.MerkleSumTree=h,"undefined"!==typeof window&&(window.MerkleSumTree=h),t.default=h}).call(this,r("1c35").Buffer)},"13ca":function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Base=void 0;const i=r("1c35"),n=s(r("3452"));class o{print(){o.print(this)}bufferIndexOf(e,t,r=!1){if(r)return this.binarySearch(e,t,i.Buffer.compare);const s=(e,t)=>e.equals(t);return this.linearSearch(e,t,s)}static binarySearch(e,t,r){let s=0,i=e.length-1;while(s<=i){const n=Math.floor((s+i)/2),o=r(e[n],t);if(0===o){for(let s=n-1;s>=0;s--)if(0!==r(e[s],t))return s+1;return 0}o<0?s=n+1:i=n-1}return-1}binarySearch(e,t,r){return o.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let s=0;s<e.length;s++)if(r(e[s],t))return s;return-1}linearSearch(e,t,r){return o.linearSearch(e,t,r)}static bufferify(e){if(!i.Buffer.isBuffer(e)){if("object"===typeof e&&e.words)return i.Buffer.from(e.toString(n.default.enc.Hex),"hex");if(o.isHexString(e)){const t=e.replace("0x",""),r=t.length%2?"0"+t:t;return i.Buffer.from(r,"hex")}if("string"===typeof e)return i.Buffer.from(e);if("bigint"===typeof e){const t=e.toString(16).length%2?"0"+e.toString(16):e.toString(16);return i.Buffer.from(t,"hex")}if(e instanceof Uint8Array)return i.Buffer.from(e.buffer,e.byteOffset,e.byteLength);if("number"===typeof e){let t=e.toString();return t.length%2&&(t="0"+t),i.Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return i.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}static bufferifyFn(e){if("function"!==typeof e)throw new Error("bufferifyFn expects a function, received: "+typeof e);return t=>{const r=e(t);if(i.Buffer.isBuffer(r))return r;if(o.isHexString(r)){const e=r.replace("0x",""),t=e.length%2?"0"+e:e;return i.Buffer.from(t,"hex")}if("string"===typeof r)return i.Buffer.from(r);if("bigint"===typeof r){const e=r.toString(16).length%2?"0"+r.toString(16):r.toString(16);return i.Buffer.from(e,"hex")}return ArrayBuffer.isView(r)?i.Buffer.from(r.buffer,r.byteOffset,r.byteLength):i.Buffer.from(e(n.default.enc.Hex.parse(t.toString("hex"))).toString(n.default.enc.Hex),"hex")}}bigNumberify(e){return o.bigNumberify(e)}static bigNumberify(e){if("bigint"===typeof e)return e;if("string"===typeof e){if(e.startsWith("0x")&&o.isHexString(e)){const t=e.replace("0x",""),r=t.length%2?"0"+t:t||"0";return BigInt("0x"+r)}return BigInt(e)}if(i.Buffer.isBuffer(e)){const t=e.toString("hex"),r=t.length%2?"0"+t:t||"0";return BigInt("0x"+r)}if(e instanceof Uint8Array){const t=i.Buffer.from(e).toString("hex"),r=t.length%2?"0"+t:t||"0";return BigInt("0x"+r)}if("number"===typeof e)return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return"string"===typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e,t=!0){return o.bufferToHex(e,t)}static bufferToHex(e,t=!0){return`${t?"0x":""}${(e||i.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return o.bufferify(e)}bufferifyFn(e){return o.bufferifyFn(e)}isHexString(e){return o.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map((e,r)=>[e,t[r]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}bufferArrayIncludes(e,t){return e.some(e=>e.equals(null!==t&&void 0!==t?t:i.Buffer.alloc(0)))}}t.Base=o,t.default=o},"26bf":function(e,t,r){(function(t,r){e.exports=r()})(0,(function(){function e(e,t){var r=t?"└":"├";return r+=e?"─ ":"──┐",r}function t(e,t){var r=[];for(var s in e)e.hasOwnProperty(s)&&(t&&"function"===typeof e[s]||r.push(s));return r}function r(s,i,n,o,h,f,a){var u,l,c="",g=0,d=o.slice(0);if(d.push([i,n])&&o.length>0&&(o.forEach((function(e,t){t>0&&(c+=(e[1]?" ":"│")+"  "),l||e[0]!==i||(l=!0)})),c+=e(s,n)+s,h&&("object"!==typeof i||i instanceof Date)&&(c+=": "+i),l&&(c+=" (circular ref.)"),a(c)),!l&&"object"===typeof i){var p=t(i,f);p.forEach((function(e){u=++g===p.length,r(e,i[e],u,d,h,f,a)}))}}var s={asLines:function(e,t,s,i){var n="function"!==typeof s&&s;r(".",e,!1,[],t,n,i||s)},asTree:function(e,t,s){var i="";return r(".",e,!1,[],t,s,(function(e){i+=e+"\n"})),i}};return s}))},"315b":function(e,t,r){"use strict";(function(e){var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleRadixTree=void 0;const i=s(r("13ca"));class n{constructor(e="",t=null,r){this.key=e,this.value=t,this.children=new Map,this.hashFn=r,this.hash=this.computeHash()}computeHash(){let t=this.hashFn("");t=e.concat([t,i.default.bufferify(this.key),null!=this.value?i.default.bufferify(this.value):e.alloc(0)]);for(const s of this.children.values())t=e.concat([t,s.hash]);const r=this.hashFn(t);return r}updateHash(){this.hash=this.computeHash()}}class o extends i.default{constructor(e){super(),this.hashFn=this.bufferifyFn(e),this.root=new n("",null,this.hashFn)}insert(e,t){let r=this.root,s=0;while(e.length>0){const i=[...r.children.values()].find(t=>e.startsWith(t.key));if(!i)return r.children.set(e,new n(e,t,this.hashFn)),void r.updateHash();if(s=this.commonPrefixLength(e,i.key),s!==i.key.length){const o=e.slice(0,s),h=i.key.slice(s),f=new n(o,null,this.hashFn);if(r.children.delete(i.key),r.children.set(o,f),f.children.set(h,i),i.key=h,s<e.length){const r=e.slice(s);f.children.set(r,new n(r,t,this.hashFn))}else f.value=t;return r.updateHash(),void f.updateHash()}r=i,e=e.slice(s)}r.value=t,r.updateHash()}lookup(e){let t=this.root;while(e.length>0){const r=[...t.children.values()].find(t=>e.startsWith(t.key));if(!r)return null;const s=this.commonPrefixLength(e,r.key);if(s!==r.key.length)return null;t=r,e=e.slice(s)}return t.value}commonPrefixLength(e,t){let r=0;while(r<e.length&&r<t.length&&e[r]===t[r])r++;return r}generateProof(e){let t=this.root;const r=[];while(e.length>0){const s=[];for(const r of t.children.values())r.key!==e&&s.push({key:r.key,hash:r.hash});r.push({key:t.key,hash:t.hash,siblings:s});const i=[...t.children.values()].find(t=>e.startsWith(t.key));if(!i)return null;const n=this.commonPrefixLength(e,i.key);if(n!==i.key.length)return null;t=i,e=e.slice(n)}return r.push({key:t.key,hash:t.hash,siblings:[]}),r}verifyProof(t,r){if(!t||0===t.length)return!1;let s=t[t.length-1].hash;for(let i=t.length-2;i>=0;i--){const r=t[i];let n=e.concat([this.hashFn(""),this.bufferify(r.key),s]);for(const t of r.siblings)n=e.concat([n,t.hash]);s=this.hashFn(n)}return s.equals(r)}}t.MerkleRadixTree=o}).call(this,r("1c35").Buffer)},"5a8c7":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UnifiedBinaryTree=t.InternalNode=t.StemNode=t.chunkifyCode=t.getTreeKeyForCodeChunk=t.getTreeKeyForStorageSlot=t.getTreeKeyForCodeHash=t.getTreeKeyForBasicData=t.getTreeKey=t.treeHash=t.oldStyleAddressToAddress32=t.push32=t.push1=t.pushOffset=t.MAIN_STORAGE_OFFSET=t.STEM_SUBTREE_WIDTH=t.CODE_OFFSET=t.HEADER_STORAGE_OFFSET=t.CODE_HASH_LEAF_KEY=t.BASIC_DATA_LEAF_KEY=void 0;const s=r("1c35"),i=r("13ca");function n(e){if(20!==e.length)throw new Error("Address must be 20 bytes.");return s.Buffer.concat([s.Buffer.alloc(12,0),e])}function o(e,t){return h(t)(e)}function h(e){return i.Base.bufferifyFn(e)}function f(e,t,r,i){if(32!==e.length)throw new Error("Address must be 32 bytes.");const n=h(i),o=s.Buffer.alloc(32,0);o.writeUInt32LE(t,0);const f=n(s.Buffer.concat([e,o]),i).subarray(0,31);return s.Buffer.concat([f,s.Buffer.from([r])])}function a(e,r){return f(e,0,t.BASIC_DATA_LEAF_KEY,r)}function u(e,r){return f(e,0,t.CODE_HASH_LEAF_KEY,r)}function l(e,r,s){let i;return i=r<t.CODE_OFFSET-t.HEADER_STORAGE_OFFSET?t.HEADER_STORAGE_OFFSET+r:t.MAIN_STORAGE_OFFSET+r,f(e,Math.floor(i/t.STEM_SUBTREE_WIDTH),i%t.STEM_SUBTREE_WIDTH,s)}function c(e,r,s){const i=t.CODE_OFFSET+r;return f(e,Math.floor(i/t.STEM_SUBTREE_WIDTH),i%t.STEM_SUBTREE_WIDTH,s)}function g(e){const r=e.length%31;0!==r&&(e=s.Buffer.concat([e,s.Buffer.alloc(31-r,0)]));const i=new Array(e.length+32).fill(0);let n=0;while(n<e.length){const r=e[n];let s=0;r>=t.push1&&r<=t.push32&&(s=r-t.pushOffset),n+=1;for(let e=0;e<s;e++)i[n+e]=s-e;n+=s}const o=[];for(let t=0;t<e.length;t+=31){const r=Math.min(i[t],31),n=s.Buffer.concat([s.Buffer.from([r]),e.slice(t,t+31)]);o.push(n)}return o}t.BASIC_DATA_LEAF_KEY=0,t.CODE_HASH_LEAF_KEY=1,t.HEADER_STORAGE_OFFSET=64,t.CODE_OFFSET=128,t.STEM_SUBTREE_WIDTH=256,t.MAIN_STORAGE_OFFSET=256,t.pushOffset=95,t.push1=t.pushOffset+1,t.push32=t.pushOffset+32,t.oldStyleAddressToAddress32=n,t.treeHash=o,t.getTreeKey=f,t.getTreeKeyForBasicData=a,t.getTreeKeyForCodeHash=u,t.getTreeKeyForStorageSlot=l,t.getTreeKeyForCodeChunk=c,t.chunkifyCode=g;class d{constructor(e){if(this.nodeType="stem",31!==e.length)throw new Error("Stem must be 31 bytes.");this.stem=e,this.values=new Array(256).fill(null)}setValue(e,t){if(32!==t.length)throw new Error("Value must be 32 bytes.");this.values[e]=t}}t.StemNode=d;class p{constructor(){this.left=null,this.right=null,this.nodeType="internal"}}t.InternalNode=p;class y{constructor(e){this.root=null,this.hashFn=i.Base.bufferifyFn(e)}insert(e,t){if(32!==e.length)throw new Error("Key must be 32 bytes.");if(32!==t.length)throw new Error("Value must be 32 bytes.");const r=e.slice(0,31),s=e[31];if(null===this.root)return this.root=new d(r),void this.root.setValue(s,t);this.root=this.insertRecursive(this.root,r,s,t,0)}insertRecursive(e,t,r,s,i){if(i>=248)throw new Error("Depth must be less than 248.");if(null===e){const e=new d(t);return e.setValue(r,s),e}const n=this.bytesToBits(t);if(e instanceof d){if(e.stem.equals(t))return e.setValue(r,s),e;const o=this.bytesToBits(e.stem);return this.splitLeaf(e,n,o,r,s,i)}{const o=n[i];return 0===o?e.left=this.insertRecursive(e.left,t,r,s,i+1):e.right=this.insertRecursive(e.right,t,r,s,i+1),e}}bytesToBits(e){const t=[];for(const r of e)for(let e=0;e<8;e++)t.push(r>>7-e&1);return t}bitsToBytes(e){if(e.length%8!==0)throw new Error("Number of bits must be a multiple of 8.");const t=[];for(let r=0;r<e.length;r+=8){let s=0;for(let t=0;t<8;t++)s|=e[r+t]<<7-t;t.push(s)}return s.Buffer.from(t)}hashData(e){const t=s.Buffer.alloc(64,0),r=s.Buffer.alloc(32,0);if(null===e||e.equals(t))return r;if(32!==e.length&&64!==e.length)throw new Error("Data must be 32 or 64 bytes.");return this.hashFn(e)}merkelize(){const e=t=>{const r=s.Buffer.alloc(32,0);if(null===t)return r;if(t instanceof p){const r=e(t.left),i=e(t.right);return this.hashData(s.Buffer.concat([r,i]))}const i=t.values.map(e=>this.hashData(e));while(i.length>1){const e=[];for(let t=0;t<i.length;t+=2)e.push(this.hashData(s.Buffer.concat([i[t],i[t+1]])));i.splice(0,i.length,...e)}return this.hashData(s.Buffer.concat([t.stem,s.Buffer.from([0]),i[0]]))};return e(this.root)}update(e,t){this.insert(e,t)}insertBatch(e){for(const{key:t,value:r}of e)this.insert(t,r)}serialize(){function e(t){return t?t instanceof d?{nodeType:"stem",stem:t.stem.toString("hex"),values:t.values.map(e=>e?e.toString("hex"):null)}:{nodeType:"internal",left:e(t.left),right:e(t.right)}:null}const t={root:e(this.root)};return s.Buffer.from(JSON.stringify(t),"utf8")}static deserialize(e,t){const r=JSON.parse(e.toString("utf8"));function i(e){if(null===e)return null;if("stem"===e.nodeType){const t=new d(s.Buffer.from(e.stem,"hex"));return t.values=e.values.map(e=>null!==e?s.Buffer.from(e,"hex"):null),t}if("internal"===e.nodeType){const t=new p;return t.left=i(e.left),t.right=i(e.right),t}return null}const n=new y(t);return n.root=i(r.root),n}splitLeaf(e,t,r,s,i,n){if(t[n]===r[n]){const o=new p,h=t[n];return 0===h?o.left=this.splitLeaf(e,t,r,s,i,n+1):o.right=this.splitLeaf(e,t,r,s,i,n+1),o}{const r=new p,o=t[n],h=this.bitsToBytes(t),f=new d(h);return f.setValue(s,i),0===o?(r.left=f,r.right=e):(r.right=f,r.left=e),r}}}t.UnifiedBinaryTree=y},6249:function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};const i=s(r("399f")),n=s(r("1c35")),o=s(r("6983")),h=n.default.Buffer;function f(e){return e=a(e),(0,o.default)("keccak256").update(e).digest()}function a(e){if(!h.isBuffer(e))if(Array.isArray(e))e=h.from(e);else if("string"===typeof e)e=u(e)?h.from(l(c(e)),"hex"):h.from(e);else if("number"===typeof e)e=d(e);else if(null===e||void 0===e)e=h.allocUnsafe(0);else if(i.default.isBN(e))e=e.toArrayLike(h);else{if(!e.toArray)throw new Error("invalid type");e=h.from(e.toArray())}return e}function u(e,t){return!("string"!==typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))&&(!t||e.length===2+2*t)}function l(e){if("string"!==typeof e)throw new Error(`while padding to even, value must be string, is currently ${typeof e}, while padToEven.`);return e.length%2&&(e="0"+e),e}function c(e){return"string"!==typeof e?e:g(e)?e.slice(2):e}function g(e){if("string"!==typeof e)throw new Error("value must be type 'string', is currently type "+typeof e+", while checking isHexPrefixed.");return"0x"===e.slice(0,2)}function d(e){const t=p(e);return h.from(l(t.slice(2)),"hex")}function p(e){const t=e.toString(16);return"0x"+t}"undefined"!==typeof window&&(window.keccak256=f),e.exports=f},"655a":function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.IncrementalMerkleTree=void 0;const i=s(r("13ca")),n=s(r("26bf"));class o extends i.default{constructor(e,t){if(super(),this.hashFn=e,t.depth&&(this.depth=t.depth),t.arity&&(this.arity=t.arity),this.depth<1)throw new Error("depth must be greater than 0");if(this.arity<1)throw new Error("arity must be greater than 0");const r=[];let s=t.zeroValue;if(this.zeroValue=s,this.zeroes=[],this.depth)for(let i=0;i<this.depth;i++)this.zeroes.push(s),r[i]=[],s=this.hashFn(Array(this.arity).fill(s));this.nodes=r,this.root=s}getRoot(){return this.root}getHexRoot(){return this.bufferToHex(this.bufferify(this.getRoot()))}insert(e){if(this.depth&&this.arity&&this.nodes[0].length>=this.getMaxLeaves())throw new Error("tree is full");let t=e,r=this.nodes[0].length;for(let s=0;s<this.depth;s+=1){const e=r%this.arity,i=r-e,n=i+this.arity,o=[];this.nodes[s][r]=t;for(let t=i;t<n;t+=1)t<this.nodes[s].length?o.push(this.nodes[s][t]):o.push(this.zeroes[s]);t=this.hashFn(o),r=Math.floor(r/this.arity)}this.root=t}delete(e){this.update(e,this.zeroValue)}update(e,t){if(e<0||e>=this.nodes[0].length)throw new Error("out of bounds");let r=t;for(let s=0;s<this.depth;s+=1){const t=e%this.arity,i=e-t,n=i+this.arity,o=[];this.nodes[s][e]=r;for(let e=i;e<n;e+=1)e<this.nodes[s].length?o.push(this.nodes[s][e]):o.push(this.zeroes[s]);r=this.hashFn(o),e=Math.floor(e/this.arity)}this.root=r}getDepth(){return this.depth}getArity(){return this.arity}getMaxLeaves(){return Math.pow(this.depth,this.arity)}indexOf(e){return this.nodes[0].indexOf(e)}getLeaves(){const e=this.copyList(this.nodes[0]),t=this.nodes[0].length;for(let r=t;r<this.getMaxLeaves();r++)e[r]=this.zeroValue;return e}copyList(e){return e.map(e=>BigInt(e))}getLayers(){const e=[];for(const t of this.nodes)e.push(this.copyList(t));if(e[0].length<this.getMaxLeaves()){let t=e[0].length;for(let r=t;r<this.getMaxLeaves();r++)e[0][r]=this.zeroValue;for(let r=0;r<this.depth;r++){const s=t%this.arity,i=t-s,n=i+this.arity;for(let t=i;t<n;t++)t>=e[r].length&&(e[r][t]=this.zeroes[r]);t=Math.floor(t/this.arity)}}return e.push([this.root]),e}getHexLayers(){return this.getLayers().reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(this.bufferify(e)))):e.push(t),e),[])}getLayersAsObject(){const e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(this.bufferify(e),!1))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const n={[e[r][i]]:null};if(t.length){n[e[r][i]]={};const s=t.shift(),o=Object.keys(s)[0];if(n[e[r][i]][o]=s[o],t.length){const s=t.shift(),o=Object.keys(s)[0];n[e[r][i]][o]=s[o]}}s.push(n)}t.push(...s)}return t[0]}computeRoot(){let e,t=this.nodes[0].length;for(let r=0;r<this.depth;r+=1){const s=t%this.arity,i=t-s,n=i+this.arity,o=[];for(let e=i;e<n;e+=1)e<this.nodes[r].length?o.push(this.nodes[r][e]):o.push(this.zeroes[r]);e=this.hashFn(o),t=Math.floor(t/this.arity)}return e}getProof(e){if(e<0||e>=this.nodes[0].length)throw new Error("The leaf does not exist in this tree");const t=[],r=[],s=e;for(let i=0;i<this.depth;i+=1){const s=e%this.arity,n=e-s,o=n+this.arity;r[i]=s,t[i]=[];for(let r=n;r<o;r+=1)r!==e&&(r<this.nodes[i].length?t[i].push(this.nodes[i][r]):t[i].push(this.zeroes[i]));e=Math.floor(e/this.arity)}return{root:this.root,leaf:this.nodes[0][s],pathIndices:r,siblings:t}}verify(e){let t=e.leaf;for(let r=0;r<e.siblings.length;r+=1){const s=e.siblings[r].slice();s.splice(e.pathIndices[r],0,t),t=this.hashFn(s)}return e.root===t}toString(){return this.toTreeString()}toTreeString(){const e=this.getLayersAsObject();return n.default.asTree(e,!0)}}t.IncrementalMerkleTree=o,"undefined"!==typeof window&&(window.IncrementalMerkleTree=o),t.default=o},"6d46":function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleTree=void 0;const i=r("1c35"),n=s(r("feaa")),o=s(r("94f8")),h=s(r("26bf")),f=s(r("13ca"));class a extends f.default{constructor(e,t=o.default,r={}){if(super(),this.duplicateOdd=!1,this.hashLeaves=!1,this.isBitcoinTree=!1,this.leaves=[],this.layers=[],this.sortLeaves=!1,this.sortPairs=!1,this.sort=!1,this.fillDefaultHash=null,this.complete=!1,r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"===typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!i.Buffer.isBuffer(r.fillDefaultHash)&&"string"!==typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}if(this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator?this.concatenator=r.concatenator:this.concatenator=i.Buffer.concat,"function"!==typeof t)throw new Error("hashFn must be a function");this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e,t;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:null!==(t=null===(e=this.fillDefaultHash)||void 0===e?void 0:e.toString())&&void 0!==t?t:null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(i.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){this.layers=[e];while(e.length>1){const t=this.layers.length;this.layers.push([]);const r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-Math.pow(2,Math.ceil(Math.log2(e.length))):e.length;for(let s=0;s<e.length;s+=2){if(s>=r){this.layers[t].push(...e.slice(r));break}if(s+1===e.length&&e.length%2===1){const r=e[e.length-1];let i=r;if(this.isBitcoinTree){i=this.hashFn(this.concatenator([n.default(r),n.default(r)])),i=n.default(this.hashFn(i)),this.layers[t].push(i);continue}if(!this.duplicateOdd){this.layers[t].push(e[s]);continue}}const o=e[s],h=s+1===e.length?o:e[s+1];let f=null;f=this.isBitcoinTree?[n.default(o),n.default(h)]:[o,h],this.sortPairs&&f.sort(i.Buffer.compare);let a=this.hashFn(this.concatenator(f));this.isBitcoinTree&&(a=n.default(this.hashFn(a))),this.layers[t].push(a)}e=this.layers[t]}}addLeaf(e,t=!1){t&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e,t=!1){t&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(i.Buffer.compare))),this.leaves.filter(t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves))):this.leaves}removeLeaf(e){if(!this.isValidLeafIndex(e))throw new Error(`"${e}" is not a valid leaf index. Expected to be [0, ${this.getLeafCount()-1}]`);const t=this.leaves.splice(e,1);return this.processLeaves(this.leaves),t[0]}updateLeaf(e,t,r=!1){if(!this.isValidLeafIndex(e))throw new Error(`"${e}" is not a valid leaf index. Expected to be [0, ${this.getLeafCount()-1}]`);r&&(t=this.hashFn(t)),this.leaves[e]=t,this.processLeaves(this.leaves)}getLeaf(e){return e<0||e>this.leaves.length-1?i.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){const s=t[r];if(s.equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(e=>a.bufferToHex(e)),null,2)}static unmarshalLeaves(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(a.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(e))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e),[]);return e.unshift(i.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?i.Buffer.from([]):this.layers[this.layers.length-1][0]||i.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if("undefined"===typeof e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===i.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let s=0;s<this.layers.length;s++){const e=this.layers[s],i=t%2,n=i?t-1:this.isBitcoinTree&&t===e.length-1&&s<this.layers.length-1?t:t+1;n<e.length&&r.push({position:i?"left":"right",data:e[n]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(e=>this.bufferToHex(e.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,r,s){const i=t%2;if(-1===e)return void(i||s.push([...r].reverse()));if(t>=this.layers[e].length)return;const n=this.layers[e],o=i?t-1:t+1;let h=!1;o<n.length&&(h=!0,r.push({position:i?"left":"right",data:n[o]}));const f=2*t,a=2*t+1;this.getProofsDFS(e-1,f,r,s),this.getProofsDFS(e-1,a,r,s),h&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(e=>["left"===e.position?0:1,this.bufferToHex(e.data)])}static marshalProof(e){const t=e.map(e=>"string"===typeof e?e:i.Buffer.isBuffer(e)?a.bufferToHex(e):{position:e.position,data:a.bufferToHex(e.data)});return JSON.stringify(t,null,2)}static unmarshalProof(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(e=>{if("string"===typeof e)return a.bufferify(e);if(e instanceof Object)return{position:e.position,data:a.bufferify(e.data)};throw new Error("Expected item to be of type string or object")})}static marshalTree(e){const t=e.getHexRoot(),r=e.leaves.map(e=>a.bufferToHex(e)),s=e.getHexLayers(),i=e.getOptions();return JSON.stringify({options:i,root:t,layers:s,leaves:r},null,2)}static unmarshalTree(e,t=o.default,r={}){let s=null;if("string"===typeof e)s=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");s=e}if(!s)throw new Error("could not parse json");return r=Object.assign({},s.options||{},r),new a(s.leaves,t,r)}getProofIndices(e,t){const r=Math.pow(2,t);let s=new Set;for(const f of e){let e=r+f;while(e>1)s.add(1^e),e=e/2|0}const i=e.map(e=>r+e),n=Array.from(s).sort((e,t)=>e-t).reverse();s=i.concat(n);const o=new Set,h=[];for(let f of s)if(!o.has(f)){h.push(f);while(f>1){if(o.add(f),!o.has(1^f))break;f=f/2|0}}return h.filter(t=>!e.includes(t-r))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),s=[];for(let o=0;o<r;o++){const e=t%2!==0;e&&s.push({index:o,leavesCount:t}),t=Math.ceil(t/2)}const i=[];let n=e;for(let o=0;o<r;o++){const e=n.map(e=>e%2===0?e+1:e-1);let t=e.filter(e=>!n.includes(e));const r=s.find(({index:e})=>e===o);r&&n.includes(r.leavesCount-1)&&(t=t.slice(0,-1)),i.push(t),n=[...new Set(n.map(e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2))]}return i}getMultiProof(e,t){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat());const r=this.isUnevenTree();if(r&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(i.Buffer.compare));let r=e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1);if(!r.every(e=>-1!==e))throw new Error("Element does not exist in Merkle tree");const s=[],n=[];let o=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const i=r[t],h=this.getPairNode(e,i);s.push(e[i]),h&&n.push(h),o.push(i/2|0)}r=o.filter((e,t,r)=>r.indexOf(e)===t),o=[]}return n.filter(e=>!s.includes(e))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(t=>e[t])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],s=t;for(const i of e){const e=[];for(const r of s){if(r%2===0){const t=r+1;if(!s.includes(t)&&i[t]){e.push(i[t]);continue}}const t=r-1;s.includes(t)||!i[t]||e.push(i[t])}r=r.concat(e);const t=new Set;for(const r of s)r%2!==0?r%2!==0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);s=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(e=>this.bufferToHex(e))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?[...e].sort((e,t)=>e===t?0:e>t?1:-1):e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1),!r.every(e=>-1!==e))throw new Error("Element does not exist in Merkle tree");const s=t.map(e=>this.bufferify(e)),i=[],n=[];for(let o=0;o<this.layers.length;o++){const e=this.layers[o];r=r.reduce((t,r)=>{const o=i.includes(e[r]);if(!o){const t=this.getPairNode(e,r),o=this.bufferArrayIncludes(s,e[r])||this.bufferArrayIncludes(s,t);t&&n.push(!o),i.push(e[r]),i.push(t)}return t.push(r/2|0),t},[])}return n}verify(e,t,r){let s=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let o=0;o<e.length;o++){const t=e[o];let r=null,h=null;if("string"===typeof t)r=this.bufferify(t),h=!0;else if(Array.isArray(t))h=0===t[0],r=this.bufferify(t[1]);else if(i.Buffer.isBuffer(t))r=t,h=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),h="left"===t.position}const f=[];this.isBitcoinTree?(f.push(n.default(s)),f[h?"unshift":"push"](n.default(r)),s=this.hashFn(this.concatenator(f)),s=n.default(this.hashFn(s))):this.sortPairs?-1===i.Buffer.compare(s,r)?(f.push(s,r),s=this.hashFn(this.concatenator(f))):(f.push(r,s),s=this.hashFn(this.concatenator(f))):(f.push(s),f[h?"unshift":"push"](r),s=this.hashFn(this.concatenator(f)))}return 0===i.Buffer.compare(s,r)}verifyMultiProof(e,t,r,s,n){const o=this.isUnevenTree();if(o)return this.verifyMultiProofForUnevenTree(e,t,r,s,n);const h=Math.ceil(Math.log2(s));e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),n=n.map(e=>this.bufferify(e));const f={};for(const[i,l]of this.zip(t,r))f[Math.pow(2,h)+i]=l;for(const[i,l]of this.zip(this.getProofIndices(t,h),n))f[i]=l;let a=Object.keys(f).map(e=>+e).sort((e,t)=>e-t);a=a.slice(0,a.length-1);let u=0;while(u<a.length){const e=a[u];if(e>=2&&{}.hasOwnProperty.call(f,1^e)){let t=[f[e-e%2],f[e-e%2+1]];this.sortPairs&&(t=t.sort(i.Buffer.compare));const r=t[1]?this.hashFn(this.concatenator(t)):t[0];f[e/2|0]=r,a.push(e/2|0)}u+=1}return!t.length||{}.hasOwnProperty.call(f,1)&&f[1].equals(e)}verifyMultiProofWithFlags(e,t,r,s){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const n=t.length,o=s.length,h=[];let f=0,a=0,u=0;for(let l=0;l<o;l++){const e=s[l]?f<n?t[f++]:h[a++]:r[u++],o=f<n?t[f++]:h[a++],c=[e,o].sort(i.Buffer.compare);h[l]=this.hashFn(this.concatenator(c))}return 0===i.Buffer.compare(h[o-1],e)}verifyMultiProofForUnevenTree(e,t,r,s,i){e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),i=i.map(e=>this.bufferify(e));const n=this.calculateRootForUnevenTree(t,r,s,i);return e.equals(n)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(e,!1))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const n={[e[r][i]]:null};if(t.length){n[e[r][i]]={};const s=t.shift(),o=Object.keys(s)[0];if(n[e[r][i]][o]=s[o],t.length){const s=t.shift(),o=Object.keys(s)[0];n[e[r][i]][o]=s[o]}}s.push(n)}t.push(...s)}return t[0]}static verify(e,t,r,s=o.default,i={}){const n=new a([],s,i);return n.verify(e,t,r)}static getMultiProof(e,t){const r=new a([]);return r.getMultiProof(e,t)}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return h.default.asTree(e,!0)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(null===e||void 0===e?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}isValidLeafIndex(e){return e>=0&&e<this.getLeafCount()}calculateRootForUnevenTree(e,t,r,s){const i=this.zip(e,t).sort(([e],[t])=>e-t),n=i.map(([e])=>e),o=this.getProofIndicesForUnevenTree(n,r);let h=0;const f=[];for(let u=0;u<o.length;u++){const e=o[u],t=h;h+=e.length,f[u]=this.zip(e,s.slice(t,h))}const a=[i];for(let u=0;u<f.length;u++){const e=f[u].concat(a[u]).sort(([e],[t])=>e-t).map(([,e])=>e),t=a[u].map(([e])=>e),r=[...new Set(t.map(e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2))],s=[];for(let i=0;i<r.length;i++){const t=r[i],n=e[2*i],o=e[2*i+1],h=o?this.hashFn(this.concatenator([n,o])):n;s.push([t,h])}a.push(s)}return a[a.length-1][0][1]}}t.MerkleTree=a,"undefined"!==typeof window&&(window.MerkleTree=a),t.default=a},b2ed:function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleMountainRange=void 0;const i=r("1c35"),n=s(r("94f8")),o=s(r("13ca"));class h extends o.default{constructor(e=n.default,t=[],r,s,o){super(),this.root=i.Buffer.alloc(0),this.size=0,this.width=0,this.hashes={},this.data={},t=t.map(this.bufferify),this.hashFn=this.bufferifyFn(e),this.hashLeafFn=r,this.peakBaggingFn=s,this.hashBranchFn=o;for(const i of t)this.append(i)}append(e){e=this.bufferify(e);const t=this.hashFn(e),r=this.bufferToHex(t);this.data[r]&&this.bufferToHex(this.hashFn(this.data[r]))===r||(this.data[r]=e);const s=this.hashLeaf(this.size+1,t);this.hashes[this.size+1]=s,this.width+=1;const i=this.getPeakIndexes(this.width);this.size=this.getSize(this.width);const n=[];for(let o=0;o<i.length;o++)n[o]=this._getOrCreateNode(i[o]);this.root=this.peakBagging(this.width,n)}hashLeaf(e,t){return t=this.bufferify(t),this.hashLeafFn?this.bufferify(this.hashLeafFn(e,t)):this.hashFn(i.Buffer.concat([this.bufferify(e),t]))}hashBranch(e,t,r){return this.hashBranchFn?this.bufferify(this.hashBranchFn(e,t,r)):this.hashFn(i.Buffer.concat([this.bufferify(e),this.bufferify(t),this.bufferify(r)]))}getPeaks(){const e=this.getPeakIndexes(this.width),t=[];for(let r=0;r<e.length;r++)t[r]=this.hashes[e[r]];return t}getLeafIndex(e){return e%2===1?this.getSize(e):this.getSize(e-1)+1}getPeakIndexes(e){const t=this.numOfPeaks(e),r=[];let s=0,i=0;for(let n=255;n>0;n--)if(0!==(e&1<<n-1)&&(i=i+(1<<n)-1,r[s++]=i,r.length>=t))break;if(s!==r.length)throw new Error("invalid bit calculation");return r}numOfPeaks(e){let t=e,r=0;while(t>0)t%2===1&&r++,t>>=1;return r}peakBagging(e,t){const r=this.getSize(e);if(this.numOfPeaks(e)!==t.length)throw new Error("received invalid number of peaks");return 0!==e||t.length?this.peakBaggingFn?this.bufferify(this.peakBaggingFn(r,t)):this.hashFn(i.Buffer.concat([this.bufferify(r),...t.map(this.bufferify)])):i.Buffer.alloc(0)}getSize(e){return(e<<1)-this.numOfPeaks(e)}getRoot(){return this.root}getHexRoot(){return this.bufferToHex(this.getRoot())}getNode(e){return this.hashes[e]}mountainHeight(e){let t=1;while(1<<t<=e+t)t++;return t-1}heightAt(e){let t=e,r=0,s=0;while(t>r)t-=(1<<s)-1,s=this.mountainHeight(t),r=(1<<s)-1;return s-(r-t)}isLeaf(e){return 1===this.heightAt(e)}getChildren(e){const t=e-(1<<this.heightAt(e)-1),r=e-1;if(t===r)throw new Error("not a parent");return[t,r]}getMerkleProof(e){if(e>this.size)throw new Error("out of range");if(!this.isLeaf(e))throw new Error("not a leaf");const t=this.root,r=this.width,s=this.getPeakIndexes(this.width),i=[];let n=0;for(let u=0;u<s.length;u++)i[u]=this.hashes[s[u]],s[u]>=e&&0===n&&(n=s[u]);let o=0,h=0,f=this.heightAt(n);const a=[];while(n!==e)f--,[o,h]=this.getChildren(n),n=e<=o?o:h,a[f-1]=this.hashes[e<=o?h:o];return{root:t,width:r,peakBagging:i,siblings:a}}verify(e,t,r,s,i,n){s=this.bufferify(s);const o=this.getSize(t);if(o<r)throw new Error("index is out of range");if(!e.equals(this.peakBagging(t,i)))throw new Error("invalid root hash from the peaks");let h,f=0;const a=this.getPeakIndexes(t);for(let p=0;p<a.length;p++)if(a[p]>=r){h=i[p],f=a[p];break}if(!h)throw new Error("target not found");let u=n.length+1;const l=new Array(u);let c,g=0,d=0;while(u>0){if(l[--u]=f,f===r)break;[g,d]=this.getChildren(f),f=r>g?d:g}while(u<l.length)f=l[u],c=0===u?this.hashLeaf(f,this.hashFn(s)):f-1===l[u-1]?this.hashBranch(f,n[u-1],c):this.hashBranch(f,c,n[u-1]),u++;if(!c.equals(h))throw new Error("hashed peak is invalid");return!0}peaksToPeakMap(e,t){const r={};let s=0,i=0,n=t.length;for(let o=1;o<=32;o++)s=32-o,i=1<<o-1,r[s]=0!==(e&i)?t[--n]:0;if(0!==n)throw new Error("invalid number of peaks");return r}peakMapToPeaks(e,t){const r=this.numOfPeaks(e),s=new Array(r);let i=0;for(let n=0;n<32;n++)0!==t[n]&&(s[i++]=t[n]);if(i!==r)throw new Error("invalid number of peaks");return s}peakUpdate(e,t,r){const s={},i=e+1;let n=this.getLeafIndex(i),o=this.hashLeaf(n,r),h=0,f=0,a=!1,u=!1,l=!1;for(let c=1;c<=32;c++)h=32-c,l?s[h]=t[h]:(f=1<<c-1,a=0!==(e&f),u=0!==(i&f),n++,a&&(o=this.hashBranch(n,t[h],o)),u?(s[h]=a?t[h]:o,l=!0):s[h]=0);return s}rollUp(e,t,r,s){if(!e.equals(this.peakBagging(t,r)))throw new Error("invalid root hash from the peaks");let i=t,n=this.peaksToPeakMap(t,r);for(let o=0;o<s.length;o++)n=this.peakUpdate(i,n,s[o]),i++;return this.peakBagging(i,this.peakMapToPeaks(i,n))}_getOrCreateNode(e){if(e>this.size)throw new Error("out of range");if(!this.hashes[e]){const[t,r]=this.getChildren(e),s=this._getOrCreateNode(t),i=this._getOrCreateNode(r);this.hashes[e]=this.hashBranch(e,s,i)}return this.hashes[e]}}t.MerkleMountainRange=h,"undefined"!==typeof window&&(window.MerkleMountainRange=h),t.default=h},db6e:function(e,t,r){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleTree=void 0;const i=s(r("6d46"));t.MerkleTree=i.default;var n=r("b2ed");Object.defineProperty(t,"MerkleMountainRange",{enumerable:!0,get:function(){return n.MerkleMountainRange}});var o=r("655a");Object.defineProperty(t,"IncrementalMerkleTree",{enumerable:!0,get:function(){return o.IncrementalMerkleTree}});var h=r("04f0");Object.defineProperty(t,"MerkleSumTree",{enumerable:!0,get:function(){return h.MerkleSumTree}});var f=r("315b");Object.defineProperty(t,"MerkleRadixTree",{enumerable:!0,get:function(){return f.MerkleRadixTree}});var a=r("5a8c7");Object.defineProperty(t,"UnifiedBinaryTree",{enumerable:!0,get:function(){return a.UnifiedBinaryTree}}),t.default=i.default},feaa:function(e,t,r){(function(t){e.exports=function(e){for(var r=new t(e.length),s=0,i=e.length-1;s<=i;++s,--i)r[s]=e[i],r[i]=e[s];return r}}).call(this,r("1c35").Buffer)}}]);