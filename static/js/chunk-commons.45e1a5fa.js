(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-commons"],{"03c1":function(n,e,t){"use strict";t("054c")},"054c":function(n,e,t){},"12f9":function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticStyle:{width:"100%",height:"100%",position:"relative"}},[t("CodeReviewDialog",{ref:"CodeReviewDialog",attrs:{title:n.$t("createTokenCard.codeReviewDialogTitle")}}),n.isIframe?n._e():t("DaBox"),t("div",{staticClass:"card"},[t("div",{staticClass:"left"},[t("div",{staticClass:"codeView",on:{click:n.onShowCodeView}},[t("svg-icon",{staticClass:"icon",attrs:{"icon-class":"code"}})],1),n.isCreateToken?t("ChangeChainBox",{ref:"ChangeChainBox"}):t("svg-icon",{staticClass:"coinIcon",attrs:{"icon-class":n.icon}}),t("h1",[n._v(n._s(n.title))]),t("p",{staticClass:"desc"},[n._v(n._s(n.desc))]),t("p",{staticClass:"desc"},[n._v(n._s(n.$t("createTokenCard.no_code")))]),t("p",{staticClass:"desc"},[n._v(n._s(n.$t("createTokenCard.you_onwer")))]),t("p",{staticClass:"desc"},[n._v(n._s(n.$t("createTokenCard.token_custom")))]),t("p",{staticClass:"desc"},[n._v(n._s(n.$t("createTokenCard.open_opensource")))]),n.isShowAdminBtn?t("el-button",{staticClass:"adminBtn",attrs:{type:"success",plain:""},on:{click:n.onGoTokenAdmin}},[n._v(n._s(n.$t("createTokenCard.token_admin")))]):n._e()],1),t("div",{staticClass:"right"},[t("div",{staticClass:"rightBox"},[n._t("default")],2)])]),t("div",{directives:[{name:"show",rawName:"v-show",value:"zh"===n.language,expression:"language === 'zh'"}],staticClass:"tips"},[n._v(n._s(n.$t("createTokenCard.tips")))])],1)},i=[],a=t("efe2"),s=(t("65f0"),t("52c1")),u={zh:{createTokenCard:{no_code:"无需任何编程技能",you_onwer:"百分百拥有代币的所有权",token_custom:"自定义代币名称、符号、发行量等",token_admin:"代币管理",open_opensource:"代币合约源代码自动发布和验证通过",tips:"本工具只用于区块链学习测试，如用于违法活动，与本站无关",changeChainDialogTitle:"切换创建Token",codeReviewDialogTitle:"合约源代码"}},en:{createTokenCard:{no_code:"No programming skills required",you_onwer:"Get 100% ownership of generated tokens",token_admin:"Token Admin",token_custom:"Custom token name, symbol and initial supply",open_opensource:"Automatic verified and published contract source code",tips:"",changeChainDialogTitle:"Change Create Token",codeReviewDialogTitle:"Contract source code"}}},o=t("3135"),d=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"ChangeChainBox"},[t("ul",n._l(n.list,(function(e){return t("li",{key:e.name,class:{on:n.$route.name===n.$coinInfo[e].createTokenRouterName},on:{click:function(t){return n.onSelect(e)}}},[t("svg-icon",{staticClass:"icon",style:{color:n.$coinInfo[e].color?n.$coinInfo[e].color:""},attrs:{"icon-class":n.$coinInfo[e].icon}}),t("span",{staticClass:"name"},[n._v(n._s(n.$coinInfo[e].chainName)+" ")])],1)})),0)])},c=[],l=t("4833"),p=(t("6a61"),t("dfe9"),{components:{},props:{},data:function(){return{list:["eth","bnb","trx","ht","ftm","matic"],loading:!0,isShowDialog:!1}},computed:Object(a["a"])({},Object(s["b"])(["isPc"])),created:function(){},mounted:function(){},methods:{onSelect:function(n){this.$coinInfo[n].createTokenRouterName!==this.$route.name&&(this.show(),this.$router.push({name:this.$coinInfo[n].createTokenRouterName}))},show:function(){var n=this;return Object(l["a"])(regeneratorRuntime.mark((function e(){return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:n.isShowDialog=!n.isShowDialog;case 1:case"end":return e.stop()}}),e)})))()}}}),m=p,f=(t("03c1"),t("5d22")),v=Object(f["a"])(m,d,c,!1,null,"7e0beeb6",null),h=v.exports,w=t("3d65"),_="createTokenCard",b={name:"Card",components:{CodeReviewDialog:o["a"],ChangeChainBox:h,DaBox:w["a"]},props:{isCreateToken:{type:Boolean,default:!0},isShowAdminBtn:{type:Boolean,default:!0},icon:{type:String,default:"coin-eth2"},title:{type:String,default:"title"},desc:{type:String,default:""},createType:{type:Number,default:0}},data:function(){return{isIframe:!1}},computed:Object(a["a"])({},Object(s["b"])(["language"])),created:function(){this.$i18n.getLocaleMessage("en")[_]||(this.$i18n.mergeLocaleMessage("en",u.en),this.$i18n.mergeLocaleMessage("zh",u.zh));var n=this.$route.query.iframe;n&&(this.isIframe=!0)},mounted:function(){},methods:{onShowCodeView:function(){this.$refs.CodeReviewDialog.show()},onGoTokenAdmin:function(){this.$router.push({name:"TokenAdmin",query:{icon:this.icon,createType:this.createType}})}}},y=b,x=(t("d224"),Object(f["a"])(y,r,i,!1,null,"49bdd0ab",null));e["a"]=x.exports},"1a9e":function(n,e,t){"use strict";t("745c")},"1ce7":function(n,e,t){},"22df":function(n,e,t){},3135:function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("el-dialog",{attrs:{width:n.isPc?"800px":"90%",visible:n.isShowDialog,center:""},on:{"update:visible":function(e){n.isShowDialog=e}}},[t("div",{staticClass:"title",attrs:{slot:"title"},slot:"title"},[t("p",[n._v(n._s(n.title))]),t("svg-icon",{staticClass:"icon",attrs:{"icon-class":"code"}})],1),t("div",{staticClass:"dialogBox"},[t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs",value:n.sourcecode,expression:"sourcecode"}]},[t("code",{staticClass:"javascript"})])]),t("span",{staticClass:"dialog-footer",attrs:{slot:"footer"},slot:"footer"},[t("el-button",{directives:[{name:"clipboard",rawName:"v-clipboard:copy",value:n.sourcecode,expression:"sourcecode",arg:"copy"},{name:"clipboard",rawName:"v-clipboard:success",value:n.onCopySuccess,expression:"onCopySuccess",arg:"success"}],attrs:{type:"primary",size:"large"}},[t("svg-icon",{attrs:{"icon-class":"copy"}}),n._v(" "+n._s(n.$t("common.copy"))+" ")],1)],1)])},i=[],a=t("4833"),s=t("efe2"),u=(t("6a61"),t("f597"),{code:'\n  pragma solidity ^0.8.4;\n  // SPDX-License-Identifier: Unlicensed\n  interface IERC20 {\n  \n      function totalSupply() external view returns (uint256);\n  \n \n      function balanceOf(address account) external view returns (uint256);\n  \n\n      function transfer(address recipient, uint256 amount) external returns (bool);\n  \n\n      function allowance(address owner, address spender) external view returns (uint256);\n\n      function approve(address spender, uint256 amount) external returns (bool);\n\n      function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  \n\n      event Transfer(address indexed from, address indexed to, uint256 value);\n  \n\n      event Approval(address indexed owner, address indexed spender, uint256 value);\n  }\n\n   \n  library SafeMath {\n\n      function add(uint256 a, uint256 b) internal pure returns (uint256) {\n          uint256 c = a + b;\n          require(c >= a, "SafeMath: addition overflow");\n  \n          return c;\n      }\n  \n\n      function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n          return sub(a, b, "SafeMath: subtraction overflow");\n      }\n\n      function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n          require(b <= a, errorMessage);\n          uint256 c = a - b;\n  \n          return c;\n      }\n  \n\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n          // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n          // benefit is lost if \'b\' is also tested.\n          // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n          if (a == 0) {\n              return 0;\n          }\n  \n          uint256 c = a * b;\n          require(c / a == b, "SafeMath: multiplication overflow");\n  \n          return c;\n      }\n  \n\n      function div(uint256 a, uint256 b) internal pure returns (uint256) {\n          return div(a, b, "SafeMath: division by zero");\n      }\n\n      function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n          require(b > 0, errorMessage);\n          uint256 c = a / b;\n          // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\n  \n          return c;\n      }\n  \n\n      function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n          return mod(a, b, "SafeMath: modulo by zero");\n      }\n  \n\n      function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n          require(b != 0, errorMessage);\n          return a % b;\n      }\n  }\n  \n  abstract contract Context {\n      function _msgSender() internal view virtual returns (address payable) {\n          return msg.sender;\n      }\n  \n      function _msgData() internal view virtual returns (bytes memory) {\n          this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n          return msg.data;\n      }\n  }\n  \n  \n  /**\n   * @dev Collection of functions related to the address type\n   */\n  library Address {\n\n      function isContract(address account) internal view returns (bool) {\n          bytes32 codehash;\n          bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n          // solhint-disable-next-line no-inline-assembly\n          assembly { codehash := extcodehash(account) }\n          return (codehash != accountHash && codehash != 0x0);\n      }\n\n      function sendValue(address payable recipient, uint256 amount) internal {\n          require(address(this).balance >= amount, "Address: insufficient balance");\n  \n          // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n          (bool success, ) = recipient.call{ value: amount }("");\n          require(success, "Address: unable to send value, recipient may have reverted");\n      }\n  \n\n      function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, "Address: low-level call failed");\n      }\n\n      function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n          return _functionCallWithValue(target, data, 0, errorMessage);\n      }\n  \n\n      function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n          return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n      }\n  \n \n      function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n          require(address(this).balance >= value, "Address: insufficient balance for call");\n          return _functionCallWithValue(target, data, value, errorMessage);\n      }\n  \n      function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n          require(isContract(target), "Address: call to non-contract");\n  \n          // solhint-disable-next-line avoid-low-level-calls\n          (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n          if (success) {\n              return returndata;\n          } else {\n              // Look for revert reason and bubble it up if present\n              if (returndata.length > 0) {\n                  // The easiest way to bubble the revert reason is using memory via assembly\n  \n                  // solhint-disable-next-line no-inline-assembly\n                  assembly {\n                      let returndata_size := mload(returndata)\n                      revert(add(32, returndata), returndata_size)\n                  }\n              } else {\n                  revert(errorMessage);\n              }\n          }\n      }\n  }\n  \n\n  contract Ownable is Context {\n      address private _owner;\n      address private _previousOwner;\n      uint256 private _lockTime;\n  \n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  \n      /**\n       * @dev Initializes the contract setting the deployer as the initial owner.\n       */\n      constructor () internal {\n          address msgSender = _msgSender();\n          _owner = msgSender;\n          emit OwnershipTransferred(address(0), msgSender);\n      }\n  \n      /**\n       * @dev Returns the address of the current owner.\n       */\n      function owner() public view returns (address) {\n          return _owner;\n      }\n  \n      /**\n       * @dev Throws if called by any account other than the owner.\n       */\n      modifier onlyOwner() {\n          require(_owner == _msgSender(), "Ownable: caller is not the owner");\n          _;\n      }\n\n      function renounceOwnership() public virtual onlyOwner {\n          emit OwnershipTransferred(_owner, address(0));\n          _owner = address(0);\n      }\n  \n\n      function transferOwnership(address newOwner) public virtual onlyOwner {\n          require(newOwner != address(0), "Ownable: new owner is the zero address");\n          emit OwnershipTransferred(_owner, newOwner);\n          _owner = newOwner;\n      }\n  \n      function geUnlockTime() public view returns (uint256) {\n          return _lockTime;\n      }\n  \n      //Locks the contract for owner for the amount of time provided\n      function lock(uint256 time) public virtual onlyOwner {\n          _previousOwner = _owner;\n          _owner = address(0);\n          _lockTime = now + time;\n          emit OwnershipTransferred(_owner, address(0));\n      }\n      \n      //Unlocks the contract for owner when _lockTime is exceeds\n      function unlock() public virtual {\n          require(_previousOwner == msg.sender, "You don\'t have permission to unlock");\n          require(now > _lockTime , "Contract is locked until 7 days");\n          emit OwnershipTransferred(_owner, _previousOwner);\n          _owner = _previousOwner;\n      }\n  }\n  \n  // pragma solidity >=0.5.0;\n  \n  interface IUniswapV2Factory {\n      event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n  \n      function feeTo() external view returns (address);\n      function feeToSetter() external view returns (address);\n  \n      function getPair(address tokenA, address tokenB) external view returns (address pair);\n      function allPairs(uint) external view returns (address pair);\n      function allPairsLength() external view returns (uint);\n  \n      function createPair(address tokenA, address tokenB) external returns (address pair);\n  \n      function setFeeTo(address) external;\n      function setFeeToSetter(address) external;\n  }\n  \n  \n  // pragma solidity >=0.5.0;\n  \n  interface IUniswapV2Pair {\n      event Approval(address indexed owner, address indexed spender, uint value);\n      event Transfer(address indexed from, address indexed to, uint value);\n  \n      function name() external pure returns (string memory);\n      function symbol() external pure returns (string memory);\n      function decimals() external pure returns (uint8);\n      function totalSupply() external view returns (uint);\n      function balanceOf(address owner) external view returns (uint);\n      function allowance(address owner, address spender) external view returns (uint);\n  \n      function approve(address spender, uint value) external returns (bool);\n      function transfer(address to, uint value) external returns (bool);\n      function transferFrom(address from, address to, uint value) external returns (bool);\n  \n      function DOMAIN_SEPARATOR() external view returns (bytes32);\n      function PERMIT_TYPEHASH() external pure returns (bytes32);\n      function nonces(address owner) external view returns (uint);\n  \n      function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n  \n      event Mint(address indexed sender, uint amount0, uint amount1);\n      event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n      event Swap(\n          address indexed sender,\n          uint amount0In,\n          uint amount1In,\n          uint amount0Out,\n          uint amount1Out,\n          address indexed to\n      );\n      event Sync(uint112 reserve0, uint112 reserve1);\n  \n      function MINIMUM_LIQUIDITY() external pure returns (uint);\n      function factory() external view returns (address);\n      function token0() external view returns (address);\n      function token1() external view returns (address);\n      function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n      function price0CumulativeLast() external view returns (uint);\n      function price1CumulativeLast() external view returns (uint);\n      function kLast() external view returns (uint);\n  \n      function mint(address to) external returns (uint liquidity);\n      function burn(address to) external returns (uint amount0, uint amount1);\n      function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n      function skim(address to) external;\n      function sync() external;\n  \n      function initialize(address, address) external;\n  }\n  \n  // pragma solidity >=0.6.2;\n  \n  interface IUniswapV2Router01 {\n      function factory() external pure returns (address);\n      function WETH() external pure returns (address);\n  \n      function addLiquidity(\n          address tokenA,\n          address tokenB,\n          uint amountADesired,\n          uint amountBDesired,\n          uint amountAMin,\n          uint amountBMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountA, uint amountB, uint liquidity);\n      function addLiquidityETH(\n          address token,\n          uint amountTokenDesired,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline\n      ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n      function removeLiquidity(\n          address tokenA,\n          address tokenB,\n          uint liquidity,\n          uint amountAMin,\n          uint amountBMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountA, uint amountB);\n      function removeLiquidityETH(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountToken, uint amountETH);\n      function removeLiquidityWithPermit(\n          address tokenA,\n          address tokenB,\n          uint liquidity,\n          uint amountAMin,\n          uint amountBMin,\n          address to,\n          uint deadline,\n          bool approveMax, uint8 v, bytes32 r, bytes32 s\n      ) external returns (uint amountA, uint amountB);\n      function removeLiquidityETHWithPermit(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline,\n          bool approveMax, uint8 v, bytes32 r, bytes32 s\n      ) external returns (uint amountToken, uint amountETH);\n      function swapExactTokensForTokens(\n          uint amountIn,\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external returns (uint[] memory amounts);\n      function swapTokensForExactTokens(\n          uint amountOut,\n          uint amountInMax,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external returns (uint[] memory amounts);\n      function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n          external\n          payable\n          returns (uint[] memory amounts);\n      function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          external\n          returns (uint[] memory amounts);\n      function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          external\n          returns (uint[] memory amounts);\n      function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n          external\n          payable\n          returns (uint[] memory amounts);\n  \n      function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n      function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n      function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n      function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n      function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n  }\n  \n  \n  \n  // pragma solidity >=0.6.2;\n  \n  interface IUniswapV2Router02 is IUniswapV2Router01 {\n      function removeLiquidityETHSupportingFeeOnTransferTokens(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountETH);\n      function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline,\n          bool approveMax, uint8 v, bytes32 r, bytes32 s\n      ) external returns (uint amountETH);\n  \n      function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n          uint amountIn,\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external;\n      function swapExactETHForTokensSupportingFeeOnTransferTokens(\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external payable;\n      function swapExactTokensForETHSupportingFeeOnTransferTokens(\n          uint amountIn,\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external;\n  }\n  \n  \n  contract CoinTool is Context, IERC20, Ownable {\n      using SafeMath for uint256;\n      using Address for address;\n  \n      mapping (address => uint256) private _rOwned;\n      mapping (address => uint256) private _tOwned;\n      mapping (address => mapping (address => uint256)) private _allowances;\n  \n      mapping (address => bool) private _isExcludedFromFee;\n  \n      mapping (address => bool) private _isExcluded;\n      address[] private _excluded;\n     \n      uint256 private constant MAX = ~uint256(0);\n      uint256 private _tTotal = 1000000000 * 10**6 * 10**9;\n      uint256 private _rTotal = (MAX - (MAX % _tTotal));\n      uint256 private _tFeeTotal;\n  \n      string private _name = "CoinTool";\n      string private _symbol = "CoinTool";\n      uint8 private _decimals = 9;\n      \n      uint256 public _taxFee = 5;\n      uint256 private _previousTaxFee = _taxFee;\n      \n      uint256 public _liquidityFee = 5;\n      uint256 private _previousLiquidityFee = _liquidityFee;\n  \n      IUniswapV2Router02 public immutable uniswapV2Router;\n      address public immutable uniswapV2Pair;\n      \n      bool inSwapAndLiquify;\n      bool public swapAndLiquifyEnabled = true;\n      \n      uint256 public _maxTxAmount = 5000000 * 10**6 * 10**9;\n      uint256 private numTokensSellToAddToLiquidity = 500000 * 10**6 * 10**9;\n\n      address public routerAddress;\n      \n      event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n      event SwapAndLiquifyEnabledUpdated(bool enabled);\n      event SwapAndLiquify(\n          uint256 tokensSwapped,\n          uint256 ethReceived,\n          uint256 tokensIntoLiqudity\n      );\n      \n      modifier lockTheSwap {\n          inSwapAndLiquify = true;\n          _;\n          inSwapAndLiquify = false;\n      }\n      \n      constructor () public {\n          _rOwned[_msgSender()] = _rTotal;\n          \n          IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\n           // Create a uniswap pair for this new token\n          uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n              .createPair(address(this), _uniswapV2Router.WETH());\n  \n          // set the rest of the contract variables\n          uniswapV2Router = _uniswapV2Router;\n          \n          //exclude owner and this contract from fee\n          _isExcludedFromFee[owner()] = true;\n          _isExcludedFromFee[address(this)] = true;\n          \n          emit Transfer(address(0), _msgSender(), _tTotal);\n      }\n  \n      function name() public view returns (string memory) {\n          return _name;\n      }\n  \n      function symbol() public view returns (string memory) {\n          return _symbol;\n      }\n  \n      function decimals() public view returns (uint8) {\n          return _decimals;\n      }\n  \n      function totalSupply() public view override returns (uint256) {\n          return _tTotal;\n      }\n  \n      function balanceOf(address account) public view override returns (uint256) {\n          if (_isExcluded[account]) return _tOwned[account];\n          return tokenFromReflection(_rOwned[account]);\n      }\n  \n      function transfer(address recipient, uint256 amount) public override returns (bool) {\n          _transfer(_msgSender(), recipient, amount);\n          return true;\n      }\n  \n      function allowance(address owner, address spender) public view override returns (uint256) {\n          return _allowances[owner][spender];\n      }\n  \n      function approve(address spender, uint256 amount) public override returns (bool) {\n          _approve(_msgSender(), spender, amount);\n          return true;\n      }\n  \n      function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n          _transfer(sender, recipient, amount);\n          _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n          return true;\n      }\n  \n      function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n          _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n          return true;\n      }\n  \n      function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n          _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n          return true;\n      }\n  \n      function isExcludedFromReward(address account) public view returns (bool) {\n          return _isExcluded[account];\n      }\n  \n      function totalFees() public view returns (uint256) {\n          return _tFeeTotal;\n      }\n  \n      function deliver(uint256 tAmount) public {\n          address sender = _msgSender();\n          require(!_isExcluded[sender], "Excluded addresses cannot call this function");\n          (uint256 rAmount,,,,,) = _getValues(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _rTotal = _rTotal.sub(rAmount);\n          _tFeeTotal = _tFeeTotal.add(tAmount);\n      }\n  \n      function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n          require(tAmount <= _tTotal, "Amount must be less than supply");\n          if (!deductTransferFee) {\n              (uint256 rAmount,,,,,) = _getValues(tAmount);\n              return rAmount;\n          } else {\n              (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n              return rTransferAmount;\n          }\n      }\n  \n      function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n          require(rAmount <= _rTotal, "Amount must be less than total reflections");\n          uint256 currentRate =  _getRate();\n          return rAmount.div(currentRate);\n      }\n  \n      function excludeFromReward(address account) public onlyOwner() {\n          // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, \'We can not exclude Uniswap router.\');\n          require(!_isExcluded[account], "Account is already excluded");\n          if(_rOwned[account] > 0) {\n              _tOwned[account] = tokenFromReflection(_rOwned[account]);\n          }\n          _isExcluded[account] = true;\n          _excluded.push(account);\n      }\n  \n      function includeInReward(address account) external onlyOwner() {\n          require(_isExcluded[account], "Account is already excluded");\n          for (uint256 i = 0; i < _excluded.length; i++) {\n              if (_excluded[i] == account) {\n                  _excluded[i] = _excluded[_excluded.length - 1];\n                  _tOwned[account] = 0;\n                  _isExcluded[account] = false;\n                  _excluded.pop();\n                  break;\n              }\n          }\n      }\n          function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _tOwned[sender] = _tOwned[sender].sub(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n      \n          function excludeFromFee(address account) public onlyOwner {\n          _isExcludedFromFee[account] = true;\n      }\n      \n      function includeInFee(address account) public onlyOwner {\n          _isExcludedFromFee[account] = false;\n      }\n      \n      function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n          _taxFee = taxFee;\n      }\n      \n      function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n          _liquidityFee = liquidityFee;\n      }\n     \n      function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n          _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n              10**2\n          );\n      }\n  \n      function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n          swapAndLiquifyEnabled = _enabled;\n          emit SwapAndLiquifyEnabledUpdated(_enabled);\n      }\n      \n       //to recieve ETH from uniswapV2Router when swaping\n      receive() external payable {}\n  \n      function _reflectFee(uint256 rFee, uint256 tFee) private {\n          _rTotal = _rTotal.sub(rFee);\n          _tFeeTotal = _tFeeTotal.add(tFee);\n      }\n  \n      function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n          (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());\n          return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n      }\n  \n      function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n          uint256 tFee = calculateTaxFee(tAmount);\n          uint256 tLiquidity = calculateLiquidityFee(tAmount);\n          uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n          return (tTransferAmount, tFee, tLiquidity);\n      }\n  \n      function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n          uint256 rAmount = tAmount.mul(currentRate);\n          uint256 rFee = tFee.mul(currentRate);\n          uint256 rLiquidity = tLiquidity.mul(currentRate);\n          uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n          return (rAmount, rTransferAmount, rFee);\n      }\n  \n      function _getRate() private view returns(uint256) {\n          (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n          return rSupply.div(tSupply);\n      }\n  \n      function _getCurrentSupply() private view returns(uint256, uint256) {\n          uint256 rSupply = _rTotal;\n          uint256 tSupply = _tTotal;      \n          for (uint256 i = 0; i < _excluded.length; i++) {\n              if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n              rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n              tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n          }\n          if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n          return (rSupply, tSupply);\n      }\n      \n      function _takeLiquidity(uint256 tLiquidity) private {\n          uint256 currentRate =  _getRate();\n          uint256 rLiquidity = tLiquidity.mul(currentRate);\n          _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n          if(_isExcluded[address(this)])\n              _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n      }\n      \n      function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n          return _amount.mul(_taxFee).div(\n              10**2\n          );\n      }\n  \n      function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n          return _amount.mul(_liquidityFee).div(\n              10**2\n          );\n      }\n      \n      function removeAllFee() private {\n          if(_taxFee == 0 && _liquidityFee == 0) return;\n          \n          _previousTaxFee = _taxFee;\n          _previousLiquidityFee = _liquidityFee;\n          \n          _taxFee = 0;\n          _liquidityFee = 0;\n      }\n      \n      function restoreAllFee() private {\n          _taxFee = _previousTaxFee;\n          _liquidityFee = _previousLiquidityFee;\n      }\n      \n      function isExcludedFromFee(address account) public view returns(bool) {\n          return _isExcludedFromFee[account];\n      }\n  \n      function _approve(address owner, address spender, uint256 amount) private {\n          require(owner != address(0), "ERC20: approve from the zero address");\n          require(spender != address(0), "ERC20: approve to the zero address");\n  \n          _allowances[owner][spender] = amount;\n          emit Approval(owner, spender, amount);\n      }\n  \n      function _transfer(\n          address from,\n          address to,\n          uint256 amount\n      ) private {\n          require(from != address(0), "ERC20: transfer from the zero address");\n          require(to != address(0), "ERC20: transfer to the zero address");\n          require(amount > 0, "Transfer amount must be greater than zero");\n          if(from != owner() && to != owner())\n              require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");\n  \n          // is the token balance of this contract address over the min number of\n          // tokens that we need to initiate a swap + liquidity lock?\n          // also, don\'t get caught in a circular liquidity event.\n          // also, don\'t swap & liquify if sender is uniswap pair.\n          uint256 contractTokenBalance = balanceOf(address(this));\n          \n          if(contractTokenBalance >= _maxTxAmount)\n          {\n              contractTokenBalance = _maxTxAmount;\n          }\n          \n          bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n          if (\n              overMinTokenBalance &&\n              !inSwapAndLiquify &&\n              from != uniswapV2Pair &&\n              swapAndLiquifyEnabled\n          ) {\n              contractTokenBalance = numTokensSellToAddToLiquidity;\n              //add liquidity\n              swapAndLiquify(contractTokenBalance);\n          }\n          \n          //indicates if fee should be deducted from transfer\n          bool takeFee = true;\n          \n          //if any account belongs to _isExcludedFromFee account then remove the fee\n          if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n              takeFee = false;\n          }\n          \n          //transfer amount, it will take tax, burn, liquidity fee\n          _tokenTransfer(from,to,amount,takeFee);\n      }\n  \n      function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n          // split the contract balance into halves\n          uint256 half = contractTokenBalance.div(2);\n          uint256 otherHalf = contractTokenBalance.sub(half);\n  \n          // capture the contract\'s current ETH balance.\n          // this is so that we can capture exactly the amount of ETH that the\n          // swap creates, and not make the liquidity event include any ETH that\n          // has been manually sent to the contract\n          uint256 initialBalance = address(this).balance;\n  \n          // swap tokens for ETH\n          swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n  \n          // how much ETH did we just swap into?\n          uint256 newBalance = address(this).balance.sub(initialBalance);\n  \n          // add liquidity to uniswap\n          addLiquidity(otherHalf, newBalance);\n          \n          emit SwapAndLiquify(half, newBalance, otherHalf);\n      }\n  \n      function swapTokensForEth(uint256 tokenAmount) private {\n          // generate the uniswap pair path of token -> weth\n          address[] memory path = new address[](2);\n          path[0] = address(this);\n          path[1] = uniswapV2Router.WETH();\n  \n          _approve(address(this), address(uniswapV2Router), tokenAmount);\n  \n          // make the swap\n          uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n              tokenAmount,\n              0, // accept any amount of ETH\n              path,\n              address(this),\n              block.timestamp\n          );\n      }\n  \n      function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n          // approve token transfer to cover all possible scenarios\n          _approve(address(this), address(uniswapV2Router), tokenAmount);\n  \n          // add the liquidity\n          uniswapV2Router.addLiquidityETH{value: ethAmount}(\n              address(this),\n              tokenAmount,\n              0, // slippage is unavoidable\n              0, // slippage is unavoidable\n              owner(),\n              block.timestamp\n          );\n      }\n  \n      //this method is responsible for taking all fee, if takeFee is true\n      function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n          if(!takeFee)\n              removeAllFee();\n          \n          if (_isExcluded[sender] && !_isExcluded[recipient]) {\n              _transferFromExcluded(sender, recipient, amount);\n          } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n              _transferToExcluded(sender, recipient, amount);\n          } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n              _transferStandard(sender, recipient, amount);\n          } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n              _transferBothExcluded(sender, recipient, amount);\n          } else {\n              _transferStandard(sender, recipient, amount);\n          }\n          \n          if(!takeFee)\n              restoreAllFee();\n      }\n  \n      function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n  \n      function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n  \n      function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _tOwned[sender] = _tOwned[sender].sub(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n  \n  \n      \n  \n  }'}),o=t("68e0"),d=t.n(o),c=t("52c1"),l=(t("17b9"),{components:{},inject:["onCopySuccess"],directives:{highlightjs:{deep:!0,bind:function(n,e){var t=n.querySelectorAll("code");t.forEach((function(n){e.value&&(n.textContent=e.value),d.a.highlightBlock(n)}))},componentUpdated:function(n,e){var t=n.querySelectorAll("code");t.forEach((function(n){e.value&&(n.textContent=e.value,d.a.highlightBlock(n))}))}}},props:{sourcecode:{type:String,default:u.code},title:{type:String,default:""}},data:function(){return{loading:!0,isShowDialog:!1}},computed:Object(s["a"])({},Object(c["b"])(["isPc"])),created:function(){},mounted:function(){},methods:{show:function(){var n=this;return Object(a["a"])(regeneratorRuntime.mark((function e(){return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:n.isShowDialog=!n.isShowDialog;case 1:case"end":return e.stop()}}),e)})))()}}}),p=l,m=(t("1a9e"),t("5d22")),f=Object(m["a"])(p,r,i,!1,null,"e4e4afbe",null);e["a"]=f.exports},3317:function(n,e,t){},"358f":function(n,e,t){"use strict";t("1ce7")},3796:function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"upload-input"},[t("input",{ref:"excel-upload-input",staticClass:"excel-upload-input",attrs:{type:"file",accept:".xlsx,.csv,.xls"},on:{change:n.handleClick}}),t("div",{staticClass:"drop",on:{drop:n.handleDrop,dragover:n.handleDragover,dragenter:n.handleDragover,click:n.handleUpload}},[n._m(0),t("p",[n._v(n._s(n.$t("common.upload_text")))])])])},i=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("p",[t("i",{staticClass:"el-icon-upload2 icon"})])}],a=(t("7479"),t("37de"),t("22f9"),t("65f0"),t("dfe9"),t("3f81")),s=t.n(a),u={props:{beforeUpload:Function,onSuccess:Function},data:function(){return{loading:!1,excelData:{header:null,results:null}}},methods:{generateData:function(n){var e=n.header,t=n.results;this.excelData.header=e,this.excelData.results=t,this.onSuccess&&this.onSuccess(this.excelData)},handleDrop:function(n){if(n.stopPropagation(),n.preventDefault(),!this.loading){var e=n.dataTransfer.files;if(1===e.length){var t=e[0];if(!this.isExcel(t))return this.$message.error("Only supports upload .xlsx, .xls, .csv suffix files"),!1;this.upload(t),n.stopPropagation(),n.preventDefault()}else this.$message.error("Only support uploading one file!")}},handleDragover:function(n){n.stopPropagation(),n.preventDefault(),n.dataTransfer.dropEffect="copy"},handleUpload:function(){this.$refs["excel-upload-input"].click()},handleClick:function(n){var e=n.target.files,t=e[0];t&&this.upload(t)},upload:function(n){if(this.$refs["excel-upload-input"].value=null,this.beforeUpload){var e=this.beforeUpload(n);e&&this.readerData(n)}else this.readerData(n)},readerData:function(n){var e=this;return this.loading=!0,new Promise((function(t,r){var i=new FileReader;i.onload=function(n){var r=n.target.result,i=s.a.read(r,{type:"array"}),a=i.SheetNames[0],u=i.Sheets[a];try{var o=!1,d={},c={},l=u["!ref"].split(":")[1].split("B")[1],p=JSON.parse(JSON.stringify(u));for(var m in p){if("A1"===m){try{p[m].w.length>=40&&(d=u[m],o=!0,p[m].t="s",p[m].v="Address",p[m].w="Address")}catch(_){p[m].v.length>=40&&(d=u[m],o=!0,p[m].t="s",p[m].v="Address",p[m].w="Address")}"Address"!==p[m].w&&(p[m].t="s",p[m].v="Address",p[m].w="Address")}"B1"===m&&(!o&&isNaN(Number(p[m].w))||(c=u[m],p[m].t="s",p[m].v="Address",p[m].w="Address"),"Amount"!==p[m].w&&(p[m].t="s",p[m].v="Amount",p[m].w="Amount"))}if(o){var f="A"+(parseInt(l)+1),v="B"+(parseInt(l)+1);p[f]=d,p[v]=c,p["!ref"]="A1:"+v}u=p}catch(_){console.log(_)}var h=e.getHeaderRow(u),w=s.a.utils.sheet_to_json(u,{raw:!1,header:0});e.generateData({header:h,results:w}),e.loading=!1,t()},i.readAsArrayBuffer(n)}))},getHeaderRow:function(n){var e,t=[],r=s.a.utils.decode_range(n["!ref"]),i=r.s.r;for(e=r.s.c;e<=r.e.c;++e){var a=n[s.a.utils.encode_cell({c:e,r:i})],u="UNKNOWN "+e;a&&a.t&&(u=s.a.utils.format_cell(a)),t.push(u)}return t},isExcel:function(n){return/\.(xlsx|xls|csv|txt)$/.test(n.name)}}},o=u,d=(t("358f"),t("5d22")),c=Object(d["a"])(o,r,i,!1,null,"a04ccbf4",null);e["a"]=c.exports},"3d65":function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return n.isShowDaBox?t("div",{staticClass:"daBox",on:{click:function(e){return n.$router.push({name:"EthOneToMore"})}}},[n._m(0),t("div",{staticClass:"closeBtn"},[t("i",{staticClass:"el-icon-close",on:{click:function(e){e.stopPropagation(),n.isShowDaBox=!1}}})])]):n._e()},i=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h3",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/c0deCn/wiki@master/logo.png"}}),n._v(" Token MultiSender ")]),t("p",[t("span",{staticClass:"label"},[n._v("Network supports:")]),t("span",{staticClass:"network"},[n._v("ETH BSC HECO DOT TRX ...")])])])}],a=t("efe2"),s=t("52c1"),u={data:function(){return{isShowDaBox:!0}},computed:Object(a["a"])({},Object(s["b"])(["isPc"])),mounted:function(){},methods:{}},o=u,d=(t("ef8f"),t("5d22")),c=Object(d["a"])(o,r,i,!1,null,"2ed33e94",null);e["a"]=c.exports},5149:function(n,e,t){"use strict";t("22df")},"66d4":function(n,e,t){},"6a8f":function(n,e,t){},"745c":function(n,e,t){},7691:function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"tabDiv"},[t("ul",{staticClass:"tabs"},n._l(n.list,(function(e){return t("li",{key:e.value,class:{on:n.active===e.value},on:{click:function(t){return n.onChangeCreateTokenActive(e.value)}}},[n._v(n._s(e.label))])})),0)])},i=[],a=(t("65f0"),{name:"CreateTokenTab",components:{},props:{list:{type:Array,default:function(){return[]}},active:{type:[Number,String],require:!0}},data:function(){return{}},methods:{onChangeCreateTokenActive:function(n){this.$emit("onChangeCreateTokenActive",n)}}}),s=a,u=(t("f987"),t("5d22")),o=Object(u["a"])(s,r,i,!1,null,"286aea9c",null);e["a"]=o.exports},"850d":function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"headerBox"},[t("div",{staticClass:"headerBg"},[t("h2",[n._v(n._s(n.title)+" "),t("i",{staticClass:"el-icon-question tutorial",on:{click:n.onLinkTutorial}})]),t("ul",{staticClass:"supportBox"},n._l(n.supportNetworks,(function(e){return t("li",{key:e.name,on:{click:function(t){return n.onChangeNetwork(e)}}},[t("div",{staticClass:"iconBox"},[t("svg-icon",{staticClass:"icon",attrs:{"icon-class":e.icon}})],1),t("span",{staticClass:"name"},[n._v(n._s(e.name))])])})),0)])])},i=[],a=t("4833"),s=(t("6a61"),t("a835")),u={name:"OneToMoreHeader",props:{supportNetworks:{default:function(){return[]},type:Array},title:{default:"",type:String}},data:function(){return{}},created:function(){},methods:{onChangeNetwork:function(n){return Object(a["a"])(regeneratorRuntime.mark((function e(){return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:e.t0=n.icon,e.next="coin-heco"===e.t0?3:"coin-ftm"===e.t0?5:"coin-bnb"===e.t0?7:"coin-okex"===e.t0?9:"coin-matic"===e.t0?11:13;break;case 3:return s["a"].addToMetamask(128),e.abrupt("return",!1);case 5:return s["a"].addToMetamask(250),e.abrupt("return",!1);case 7:return s["a"].addToMetamask(56),e.abrupt("return",!1);case 9:return s["a"].addToMetamask(66),e.abrupt("return",!1);case 11:return s["a"].addToMetamask(137),e.abrupt("return",!1);case 13:case"end":return e.stop()}}),e)})))()},onLinkTutorial:function(){this.$router.push({name:"doc",query:{tab:"ethOneToMore"}})}}},o=u,d=(t("c01c"),t("5d22")),c=Object(d["a"])(o,r,i,!1,null,"0795bf46",null);e["a"]=c.exports},a78a:function(n,e,t){},c01c:function(n,e,t){"use strict";t("66d4")},d224:function(n,e,t){"use strict";t("3317")},ef8f:function(n,e,t){"use strict";t("6a8f")},f987:function(n,e,t){"use strict";t("a78a")},fa7e:function(n,e,t){"use strict";var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"editor"},[t("textarea",{ref:"textarea",attrs:{placeholder:n.placeholder}})])},i=[],a=t("012b"),s=t.n(a),u=(t("dcf6"),t("e5d4"),t("f3f2"),t("ab82"),{name:"JsonEditor",props:{placeholder:{type:String,required:!0},value:{type:[String,Array],required:!0}},data:function(){return{jsonEditor:!1}},watch:{value:function(n){var e=this.jsonEditor.getValue();n!==e&&this.jsonEditor.setValue(n)}},mounted:function(){var n=this;this.jsonEditor=s.a.fromTextArea(this.$refs.textarea,{lineNumbers:!0,mode:"string",theme:"idea",styleActiveLine:!0,lint:!0}),this.jsonEditor.setValue(this.value),this.jsonEditor.on("change",(function(e){n.$emit("changed",e.getValue()),n.$emit("input",e.getValue())}))},methods:{getValue:function(){return this.jsonEditor.getValue()}}}),o=u,d=(t("5149"),t("5d22")),c=Object(d["a"])(o,r,i,!1,null,"21748925",null);e["a"]=c.exports}}]);