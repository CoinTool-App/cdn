(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-f563d640"],{"1f71":function(t,e,r){"use strict";r.r(e),r.d(e,"CURVE",(function(){return f})),r.d(e,"Point",(function(){return A})),r.d(e,"Signature",(function(){return R})),r.d(e,"getPublicKey",(function(){return nt})),r.d(e,"recoverPublicKey",(function(){return it})),r.d(e,"getSharedSecret",(function(){return st})),r.d(e,"sign",(function(){return lt})),r.d(e,"signSync",(function(){return wt})),r.d(e,"verify",(function(){return yt})),r.d(e,"schnorr",(function(){return Pt})),r.d(e,"utils",(function(){return Ut}));var n=r(41);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const i=BigInt(0),o=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),f=Object.freeze({a:i,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:o,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),u=(t,e)=>(t+e/s)/e,h={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:e}=f,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-o*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,a=BigInt("0x100000000000000000000000000000000"),c=u(s*t,e),h=u(-n*t,e);let l=D(t-c*r-h*i,e),w=D(-c*n-h*s,e);const d=l>a,y=w>a;if(d&&(l=e-l),y&&(w=e-w),l>a||w>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:d,k1:l,k2neg:y,k2:w}}},l=32,w=32,d=32,y=l+1,g=2*l+1;function p(t){const{a:e,b:r}=f,n=D(t*t),i=D(n*t);return D(i+e*t+r)}const E=f.a===i;class m extends Error{constructor(t){super(t)}}function x(t){if(!(t instanceof v))throw new TypeError("JacobianPoint expected")}class v{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof A))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(A.ZERO)?v.ZERO:new v(t.x,t.y,o)}static toAffineBatch(t){const e=j(t.map(t=>t.z));return t.map((t,r)=>t.toAffine(e[r]))}static normalizeZ(t){return v.toAffineBatch(t).map(v.fromAffine)}equals(t){x(t);const{x:e,y:r,z:n}=this,{x:i,y:o,z:s}=t,a=D(n*n),c=D(s*s),f=D(e*c),u=D(i*a),h=D(D(r*s)*c),l=D(D(o*n)*a);return f===u&&h===l}negate(){return new v(this.x,D(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=D(t*t),i=D(e*e),o=D(i*i),f=t+i,u=D(s*(D(f*f)-n-o)),h=D(a*n),l=D(h*h),w=D(l-s*u),d=D(h*(u-w)-c*o),y=D(s*e*r);return new v(w,d,y)}add(t){x(t);const{x:e,y:r,z:n}=this,{x:o,y:a,z:c}=t;if(o===i||a===i)return this;if(e===i||r===i)return t;const f=D(n*n),u=D(c*c),h=D(e*u),l=D(o*f),w=D(D(r*c)*u),d=D(D(a*n)*f),y=D(l-h),g=D(d-w);if(y===i)return g===i?this.double():v.ZERO;const p=D(y*y),E=D(y*p),m=D(h*p),b=D(g*g-E-s*m),S=D(g*(m-b)-w*E),A=D(n*c*y);return new v(b,S,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=v.ZERO;if("bigint"===typeof t&&t===i)return e;let r=Z(t);if(r===o)return this;if(!E){let t=e,n=this;while(r>i)r&o&&(t=t.add(n)),n=n.double(),r>>=o;return t}let{k1neg:n,k1:s,k2neg:a,k2:c}=h.splitScalar(r),f=e,u=e,l=this;while(s>i||c>i)s&o&&(f=f.add(l)),c&o&&(u=u.add(l)),l=l.double(),s>>=o,c>>=o;return n&&(f=f.negate()),a&&(u=u.negate()),u=new v(D(u.x*h.beta),u.y,u.z),f.add(u)}precomputeWindow(t){const e=E?128/t+1:256/t+1,r=[];let n=this,i=n;for(let o=0;o<e;o++){i=n,r.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(n),r.push(i);n=i.double()}return r}wNAF(t,e){!e&&this.equals(v.BASE)&&(e=A.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&S.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=v.normalizeZ(n),S.set(e,n)));let i=v.ZERO,s=v.BASE;const a=1+(E?128/r:256/r),c=2**(r-1),f=BigInt(2**r-1),u=2**r,h=BigInt(r);for(let l=0;l<a;l++){const e=l*c;let r=Number(t&f);t>>=h,r>c&&(r-=u,t+=o);const a=e,w=e+Math.abs(r)-1,d=l%2!==0,y=r<0;0===r?s=s.add(b(d,n[a])):i=i.add(b(y,n[w]))}return{p:i,f:s}}multiply(t,e){let r,n,i=Z(t);if(E){const{k1neg:t,k1:o,k2neg:s,k2:a}=h.splitScalar(i);let{p:c,f:f}=this.wNAF(o,e),{p:u,f:l}=this.wNAF(a,e);c=b(t,c),u=b(s,u),u=new v(D(u.x*h.beta),u.y,u.z),r=c.add(u),n=f.add(l)}else{const{p:t,f:o}=this.wNAF(i,e);r=t,n=o}return v.normalizeZ([r,n])[0]}toAffine(t){const{x:e,y:r,z:n}=this,i=this.equals(v.ZERO);null==t&&(t=i?c:W(n));const s=t,a=D(s*s),f=D(a*s),u=D(e*a),h=D(r*f),l=D(n*s);if(i)return A.ZERO;if(l!==o)throw new Error("invZ was invalid");return new A(u,h)}}function b(t,e){const r=e.negate();return t?r:e}v.BASE=new v(f.Gx,f.Gy,o),v.ZERO=new v(i,o,i);const S=new WeakMap;class A{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,S.delete(this)}hasEvenY(){return this.y%s===i}static fromCompressedHex(t){const e=32===t.length,r=K(e?t:t.subarray(1));if(!Y(r))throw new Error("Point is not on curve");const n=p(r);let i=q(n);const s=(i&o)===o;if(e)s&&(i=D(-i));else{const e=1===(1&t[0]);e!==s&&(i=D(-i))}const a=new A(r,i);return a.assertValidity(),a}static fromUncompressedHex(t){const e=K(t.subarray(1,l+1)),r=K(t.subarray(l+1,2*l+1)),n=new A(e,r);return n.assertValidity(),n}static fromHex(t){const e=$(t),r=e.length,n=e[0];if(r===l)return this.fromCompressedHex(e);if(r===y&&(2===n||3===n))return this.fromCompressedHex(e);if(r===g&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${g} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return A.BASE.multiply(tt(t))}static fromSignature(t,e,r){const{r:n,s:i}=rt(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const o=X($(t)),{n:s}=f,a=2===r||3===r?n+s:n,c=W(a,s),u=D(-o*c,s),h=D(i*c,s),l=1&r?"03":"02",w=A.fromHex(l+z(a)),d=A.BASE.multiplyAndAddUnsafe(w,u,h);if(!d)throw new Error("Cannot recover signature: point at infinify");return d.assertValidity(),d}toRawBytes(t=!1){return V(this.toHex(t))}toHex(t=!1){const e=z(this.x);if(t){const t=this.hasEvenY()?"02":"03";return`${t}${e}`}return`04${e}${z(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!Y(e)||!Y(r))throw new Error(t);const n=D(r*r),o=p(e);if(D(n-o)!==i)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new A(this.x,D(-this.y))}double(){return v.fromAffine(this).double().toAffine()}add(t){return v.fromAffine(this).add(v.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return v.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=v.fromAffine(this),s=e===i||e===o||this!==A.BASE?n.multiplyUnsafe(e):n.multiply(e),a=v.fromAffine(t).multiplyUnsafe(r),c=s.add(a);return c.equals(v.ZERO)?void 0:c.toAffine()}}function B(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function P(t){if(t.length<2||2!==t[0])throw new Error("Invalid signature integer tag: "+k(t));const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:K(r),left:t.subarray(e+2)}}function I(t){if(t.length<2||48!=t[0])throw new Error("Invalid signature tag: "+k(t));if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=P(t.subarray(2)),{data:n,left:i}=P(r);if(i.length)throw new Error("Invalid signature: left bytes after parsing: "+k(i));return{r:e,s:n}}A.BASE=new A(f.Gx,f.Gy),A.ZERO=new A(i,i);class R{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!==typeof t&&!e)throw new TypeError(r+": Expected string or Uint8Array");const n=e?k(t):t;if(128!==n.length)throw new Error(r+": Expected 64-byte hex");return new R(C(n.slice(0,64)),C(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!==typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:r,s:n}=I(e?t:V(t));return new R(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!M(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!M(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=f.n>>o;return this.s>t}normalizeS(){return this.hasHighS()?new R(this.r,D(-this.s,f.n)):this}toDERRawBytes(){return V(this.toDERHex())}toDERHex(){const t=B(O(this.s)),e=B(O(this.r)),r=t.length/2,n=e.length/2,i=O(r),o=O(n),s=O(n+r+4);return`30${s}02${o}${e}02${i}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return V(this.toCompactHex())}toCompactHex(){return z(this.r)+z(this.s)}}function H(...t){if(!t.every(t=>t instanceof Uint8Array))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce((t,e)=>t+e.length,0),r=new Uint8Array(e);for(let n=0,i=0;n<t.length;n++){const e=t[n];r.set(e,i),i+=e.length}return r}const U=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function k(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=U[t[r]];return e}const T=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function z(t){if("bigint"!==typeof t)throw new Error("Expected bigint");if(!(i<=t&&t<T))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function N(t){const e=V(z(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function O(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function C(t){if("string"!==typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt("0x"+t)}function V(t){if("string"!==typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[r]=o}return e}function K(t){return C(k(t))}function $(t){return t instanceof Uint8Array?Uint8Array.from(t):V(t)}function Z(t){if("number"===typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"===typeof t&&M(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function D(t,e=f.P){const r=t%e;return r>=i?r:e+r}function _(t,e){const{P:r}=f;let n=t;while(e-- >i)n*=n,n%=r;return n}function q(t){const{P:e}=f,r=BigInt(6),n=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),u=BigInt(88),h=t*t*t%e,l=h*h*t%e,w=_(l,a)*l%e,d=_(w,a)*l%e,y=_(d,s)*h%e,g=_(y,n)*y%e,p=_(g,i)*g%e,E=_(p,c)*p%e,m=_(E,u)*E%e,x=_(m,c)*p%e,v=_(x,a)*l%e,b=_(v,o)*g%e,S=_(b,r)*h%e,A=_(S,s),B=A*A%e;if(B!==t)throw new Error("Cannot find square root");return A}function W(t,e=f.P){if(t===i||e<=i)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=D(t,e),n=e,s=i,a=o,c=o,u=i;while(r!==i){const t=n/r,e=n%r,i=s-c*t,o=a-u*t;n=r,r=e,s=c,a=u,c=i,u=o}const h=n;if(h!==o)throw new Error("invert: does not exist");return D(s,e)}function j(t,e=f.P){const r=new Array(t.length),n=t.reduce((t,n,o)=>n===i?t:(r[o]=t,D(t*n,e)),o),s=W(n,e);return t.reduceRight((t,n,o)=>n===i?t:(r[o]=D(t*r[o],e),D(t*n,e)),s),r}function F(t){const e=8*t.length-8*w,r=K(t);return e>0?r>>BigInt(e):r}function X(t,e=!1){const r=F(t);if(e)return r;const{n:n}=f;return r>=n?r-n:r}let G,L;class J{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,"number"!==typeof t||t<2)throw new Error("hashLen must be a number");if("number"!==typeof e||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return Ut.hmacSha256(this.k,...t)}hmacSync(...t){return L(this.k,...t)}checkSync(){if("function"!==typeof L)throw new m("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0;const e=[];while(t<this.qByteLen){this.v=await this.hmac(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return H(...e)}generateSync(){this.checkSync(),this.incr();let t=0;const e=[];while(t<this.qByteLen){this.v=this.hmacSync(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return H(...e)}}function M(t){return i<t&&t<f.n}function Y(t){return i<t&&t<f.P}function Q(t,e,r,n=!0){const{n:s}=f,a=X(t,!0);if(!M(a))return;const c=W(a,s),u=A.BASE.multiply(a),h=D(u.x,s);if(h===i)return;const l=D(c*D(e+r*h,s),s);if(l===i)return;let w=new R(h,l),d=(u.x===w.r?0:2)|Number(u.y&o);return n&&w.hasHighS()&&(w=w.normalizeS(),d^=1),{sig:w,recovery:d}}function tt(t){let e;if("bigint"===typeof t)e=t;else if("number"===typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"===typeof t){if(t.length!==2*w)throw new Error("Expected 32 bytes of private key");e=C(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(t.length!==w)throw new Error("Expected 32 bytes of private key");e=K(t)}if(!M(e))throw new Error("Expected private key: 0 < key < n");return e}function et(t){return t instanceof A?(t.assertValidity(),t):A.fromHex(t)}function rt(t){if(t instanceof R)return t.assertValidity(),t;try{return R.fromDER(t)}catch(e){return R.fromCompact(t)}}function nt(t,e=!1){return A.fromPrivateKey(t).toRawBytes(e)}function it(t,e,r,n=!1){return A.fromSignature(t,e,r).toRawBytes(n)}function ot(t){const e=t instanceof Uint8Array,r="string"===typeof t,n=(e||r)&&t.length;return e?n===y||n===g:r?n===2*y||n===2*g:t instanceof A}function st(t,e,r=!1){if(ot(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!ot(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=et(e);return n.assertValidity(),n.multiply(tt(t)).toRawBytes(r)}function at(t){const e=t.length>l?t.slice(0,l):t;return K(e)}function ct(t){const e=at(t),r=D(e,f.n);return ft(r<i?e:r)}function ft(t){return N(t)}function ut(t,e,r){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const n=$(t),i=tt(e),o=[ft(i),ct(n)];if(null!=r){!0===r&&(r=Ut.randomBytes(l));const t=$(r);if(t.length!==l)throw new Error(`sign: Expected ${l} bytes of extra data`);o.push(t)}const s=H(...o),a=at(n);return{seed:s,m:a,d:i}}function ht(t,e){const{sig:r,recovery:n}=t,{der:i,recovered:o}=Object.assign({canonical:!0,der:!0},e),s=i?r.toDERRawBytes():r.toCompactRawBytes();return o?[s,n]:s}async function lt(t,e,r={}){const{seed:n,m:i,d:o}=ut(t,e,r.extraEntropy),s=new J(d,w);let a;await s.reseed(n);while(!(a=Q(await s.generate(),i,o,r.canonical)))await s.reseed();return ht(a,r)}function wt(t,e,r={}){const{seed:n,m:i,d:o}=ut(t,e,r.extraEntropy),s=new J(d,w);let a;s.reseedSync(n);while(!(a=Q(s.generateSync(),i,o,r.canonical)))s.reseedSync();return ht(a,r)}const dt={strict:!0};function yt(t,e,r,n=dt){let i;try{i=rt(t),e=$(e)}catch(g){return!1}const{r:o,s:s}=i;if(n.strict&&i.hasHighS())return!1;const a=X(e);let c;try{c=et(r)}catch(g){return!1}const{n:u}=f,h=W(s,u),l=D(a*h,u),w=D(o*h,u),d=A.BASE.multiplyAndAddUnsafe(c,l,w);if(!d)return!1;const y=D(d.x,u);return y===o}function gt(t){return D(K(t),f.n)}class pt{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=$(t);if(64!==e.length)throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not "+e.length);const r=K(e.subarray(0,32)),n=K(e.subarray(32,64));return new pt(r,n)}assertValidity(){const{r:t,s:e}=this;if(!Y(t)||!M(e))throw new Error("Invalid signature")}toHex(){return z(this.r)+z(this.s)}toRawBytes(){return V(this.toHex())}}function Et(t){return A.fromPrivateKey(t).toRawX()}class mt{constructor(t,e,r=Ut.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=$(t);const{x:n,scalar:i}=this.getScalar(tt(e));if(this.px=n,this.d=i,this.rand=$(r),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=A.fromPrivateKey(t),r=e.hasEvenY()?t:f.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return N(t^K(e))}finalizeNonce(t){const e=D(K(t),f.n);if(e===i)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:o}=this.getScalar(e);return{R:r,rx:n,k:o}}finalizeSig(t,e,r,n){return new pt(t.x,D(e+r*n,f.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:r,rand:n}=this,i=Ut.taggedHash,o=this.initNonce(e,await i(Rt.aux,n)),{R:s,rx:a,k:c}=this.finalizeNonce(await i(Rt.nonce,o,r,t)),f=gt(await i(Rt.challenge,a,r,t)),u=this.finalizeSig(s,c,f,e);return await At(u,t,r)||this.error(),u}calcSync(){const{m:t,d:e,px:r,rand:n}=this,i=Ut.taggedHashSync,o=this.initNonce(e,i(Rt.aux,n)),{R:s,rx:a,k:c}=this.finalizeNonce(i(Rt.nonce,o,r,t)),f=gt(i(Rt.challenge,a,r,t)),u=this.finalizeSig(s,c,f,e);return Bt(u,t,r)||this.error(),u}}async function xt(t,e,r){return new mt(t,e,r).calc()}function vt(t,e,r){return new mt(t,e,r).calcSync()}function bt(t,e,r){const n=t instanceof pt,i=n?t:pt.fromHex(t);return n&&i.assertValidity(),{...i,m:$(e),P:et(r)}}function St(t,e,r,n){const i=A.BASE.multiplyAndAddUnsafe(e,tt(r),D(-n,f.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function At(t,e,r){try{const{r:n,s:i,m:o,P:s}=bt(t,e,r),a=gt(await Ut.taggedHash(Rt.challenge,N(n),s.toRawX(),o));return St(n,s,i,a)}catch(n){return!1}}function Bt(t,e,r){try{const{r:n,s:i,m:o,P:s}=bt(t,e,r),a=gt(Ut.taggedHashSync(Rt.challenge,N(n),s.toRawX(),o));return St(n,s,i,a)}catch(n){if(n instanceof m)throw n;return!1}}const Pt={Signature:pt,getPublicKey:Et,sign:xt,verify:At,signSync:vt,verifySync:Bt};A.BASE._setWindowSize(8);const It={node:n,web:"object"===typeof self&&"crypto"in self?self.crypto:void 0},Rt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},Ht={},Ut={bytesToHex:k,hexToBytes:V,concatBytes:H,mod:D,invert:W,isValidPrivateKey(t){try{return tt(t),!0}catch(e){return!1}},_bigintTo32Bytes:N,_normalizePrivateKey:tt,hashToPrivateKey:t=>{t=$(t);const e=w+8;if(t.length<e||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");const r=D(K(t),f.n-o)+o;return N(r)},randomBytes:(t=32)=>{if(It.web)return It.web.getRandomValues(new Uint8Array(t));if(It.node){const{randomBytes:e}=It.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>Ut.hashToPrivateKey(Ut.randomBytes(w+8)),precompute(t=8,e=A.BASE){const r=e===A.BASE?e:new A(e.x,e.y);return r._setWindowSize(t),r.multiply(a),r},sha256:async(...t)=>{if(It.web){const e=await It.web.subtle.digest("SHA-256",H(...t));return new Uint8Array(e)}if(It.node){const{createHash:e}=It.node,r=e("sha256");return t.forEach(t=>r.update(t)),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(It.web){const r=await It.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=H(...e),i=await It.web.subtle.sign("HMAC",r,n);return new Uint8Array(i)}if(It.node){const{createHmac:r}=It.node,n=r("sha256",t);return e.forEach(t=>n.update(t)),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let r=Ht[t];if(void 0===r){const e=await Ut.sha256(Uint8Array.from(t,t=>t.charCodeAt(0)));r=H(e,e),Ht[t]=r}return Ut.sha256(r,...e)},taggedHashSync:(t,...e)=>{if("function"!==typeof G)throw new m("sha256Sync is undefined, you need to set it");let r=Ht[t];if(void 0===r){const e=G(Uint8Array.from(t,t=>t.charCodeAt(0)));r=H(e,e),Ht[t]=r}return G(r,...e)},_JacobianPoint:v};Object.defineProperties(Ut,{sha256Sync:{configurable:!1,get(){return G},set(t){G||(G=t)}},hmacSha256Sync:{configurable:!1,get(){return L},set(t){L||(L=t)}}})},"262f":function(t,e,r){"use strict";(function(t){var n=r("1f71"),i=r("e632"),o=r("d129");function s(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var a=s(n);a.utils.hmacSha256Sync=(t,...e)=>i.hmac(o.sha256,t,a.utils.concatBytes(...e)),a.utils.sha256Sync=(...t)=>o.sha256(a.utils.concatBytes(...t));const c=a.utils._normalizePrivateKey,f=32,u=32,h=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,186,174,220,230,175,72,160,59,191,210,94,140,208,54,65,65]),l=32;function w(t,e){for(let r=0;r<32;++r)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function d(t){return t instanceof Uint8Array&&t.length===u&&!(w(t,h)>=0)}function y(t){return t instanceof Uint8Array&&64===t.length&&w(t.subarray(0,32),h)<0&&w(t.subarray(32,64),h)<0}function g(t){return t instanceof Uint8Array&&t.length===f}function p(t){return void 0===t||t instanceof Uint8Array&&t.length===l}function E(t){if("string"!==typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt("0x"+t)}function m(t){return E(a.utils.bytesToHex(t))}function x(t){let e;if("bigint"===typeof t)e=t;else if("number"===typeof t&&Number.isSafeInteger(t)&&t>=0)e=BigInt(t);else if("string"===typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private scalar");e=E(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private scalar");if(32!==t.length)throw new Error("Expected 32 bytes of private scalar");e=m(t)}if(e<0)throw new Error("Expected private scalar >= 0");return e}const v=(t,e)=>{const r=c(t),n=x(e),i=a.utils._bigintTo32Bytes(a.utils.mod(r+n,a.CURVE.n));return a.utils.isValidPrivateKey(i)?i:null},b=(t,e)=>{const r=c(t),n=x(e),i=a.utils._bigintTo32Bytes(a.utils.mod(r-n,a.CURVE.n));return a.utils.isValidPrivateKey(i)?i:null},S=t=>{const e=c(t),r=a.utils._bigintTo32Bytes(a.CURVE.n-e);return a.utils.isValidPrivateKey(r)?r:null},A=(t,e,r)=>{const n=a.Point.fromHex(t),i=x(e),o=a.Point.BASE.multiplyAndAddUnsafe(n,i,1n);if(!o)throw new Error("Tweaked point at infinity");return o.toRawBytes(r)},B=(t,e,r)=>{const n=a.Point.fromHex(t),i="string"===typeof e?e:a.utils.bytesToHex(e),o=BigInt("0x"+i);return n.multiply(o).toRawBytes(r)};function P(t,e){return void 0===t?void 0===e||U(e):!!t}function I(t){try{return t()}catch(e){return null}}function R(t,e){if(32===t.length!==e)return!1;try{return!!a.Point.fromHex(t)}catch(r){return!1}}function H(t){return R(t,!1)}function U(t){const e=33;return R(t,!1)&&t.length===e}function k(t){return a.utils.isValidPrivateKey(t)}function T(t){return R(t,!0)}function z(t,e){if(!T(t))throw new Error("Expected Point");if(!d(e))throw new Error("Expected Tweak");return I(()=>{const r=A(t,e,!0),n=r[0]%2===1?1:0;return{parity:n,xOnlyPubkey:r.slice(1)}})}function N(t){if(!H(t))throw new Error("Expected Point");return t.slice(1,33)}function O(t,e){if(!k(t))throw new Error("Expected Private");return I(()=>a.getPublicKey(t,P(e)))}function C(t){if(!k(t))throw new Error("Expected Private");return N(O(t))}function V(t,e){if(!H(t))throw new Error("Expected Point");return a.Point.fromHex(t).toRawBytes(P(e,t))}function K(t,e,r){if(!H(t))throw new Error("Expected Point");if(!d(e))throw new Error("Expected Tweak");return I(()=>B(t,e,P(r,t)))}function $(t,e,r){if(!H(t)||!H(e))throw new Error("Expected Point");return I(()=>{const n=a.Point.fromHex(t),i=a.Point.fromHex(e);return n.equals(i.negate())?null:n.add(i).toRawBytes(P(r,t))})}function Z(t,e,r){if(!H(t))throw new Error("Expected Point");if(!d(e))throw new Error("Expected Tweak");return I(()=>A(t,e,P(r,t)))}function D(t,e){if(!1===k(t))throw new Error("Expected Private");if(!1===d(e))throw new Error("Expected Tweak");return I(()=>v(t,e))}function _(t,e){if(!1===k(t))throw new Error("Expected Private");if(!1===d(e))throw new Error("Expected Tweak");return I(()=>b(t,e))}function q(t){if(!1===k(t))throw new Error("Expected Private");return S(t)}function W(t,e,r){if(!k(e))throw new Error("Expected Private");if(!g(t))throw new Error("Expected Scalar");if(!p(r))throw new Error("Expected Extra Data (32 bytes)");return a.signSync(t,e,{der:!1,extraEntropy:r})}function j(e,r,n=t.alloc(32,0)){if(!k(r))throw new Error("Expected Private");if(!g(e))throw new Error("Expected Scalar");if(!p(n))throw new Error("Expected Extra Data (32 bytes)");return a.schnorr.signSync(e,r,n)}function F(t,e,r,n){if(!H(e))throw new Error("Expected Point");if(!y(r))throw new Error("Expected Signature");if(!g(t))throw new Error("Expected Scalar");return a.verify(r,t,e,{strict:n})}function X(t,e,r){if(!T(e))throw new Error("Expected Point");if(!y(r))throw new Error("Expected Signature");if(!g(t))throw new Error("Expected Scalar");return a.schnorr.verifySync(r,t,e)}e.isPoint=H,e.isPointCompressed=U,e.isPrivate=k,e.isXOnlyPoint=T,e.pointAdd=$,e.pointAddScalar=Z,e.pointCompress=V,e.pointFromScalar=O,e.pointMultiply=K,e.privateAdd=D,e.privateNegate=q,e.privateSub=_,e.sign=W,e.signSchnorr=j,e.verify=F,e.verifySchnorr=X,e.xOnlyPointAddTweak=z,e.xOnlyPointFromPoint=N,e.xOnlyPointFromScalar=C}).call(this,r("1c35").Buffer)}}]);