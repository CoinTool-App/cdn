(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-10c268fc"],{"266f":function(n,e,t){"use strict";t("52cf")},"3fea":function(n,e,t){"use strict";var a=this&&this.__assign||function(){return a=Object.assign||function(n){for(var e,t=1,a=arguments.length;t<a;t++)for(var r in e=arguments[t],e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n},a.apply(this,arguments)};Object.defineProperty(e,"__esModule",{value:!0}),e.createCompileInput=void 0;var r=function(n,e){void 0===e&&(e={});var t={language:"Solidity",sources:{Compiled_Contracts:{content:n}},settings:a(a({},e),{outputSelection:{"*":{"*":["*"]}}})};return JSON.stringify(t)};e.createCompileInput=r},"46a4":function(n,e,t){"use strict";t.r(e);var a=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"container"},[t("div",{staticClass:"header"},[t("el-button",{on:{click:n.onTokenApprove}},[n._v("Token Approve")]),t("el-button",{on:{click:n.onNFTApprove}},[n._v("NFT 721 Approve")]),t("el-button",{on:{click:n.onTransNative}},[n._v("BSC 本币 转账")]),t("el-button",{on:{click:n.onTransToken}},[n._v("BSC token 转账")]),t("el-button",{on:{click:n.onNFTTrans}},[n._v("BSC 721 nft 转移")]),t("el-button",{on:{click:n.onIPFS}},[n._v("onIPFS")])],1)])},r=[],i=t("5af6"),s=t("4833"),d=t("efe2"),o=t("5937"),u=(t("65f0"),t("7479"),t("4a32"),t("37de"),t("1e34"),t("9bdd"),t("6a61"),t("5a50")),c=t("52c1"),l={zh:{rpcServer:{}},en:{rpcServer:{}}},m=t("a835"),p=t("8feb"),f=t.n(p),v=t("85d4"),w=t("e046"),b=t.n(w),h=t("7921"),k=t.n(h),y=t("7742"),g=t.n(y),x=t("caa7"),T="demo",F=[{constant:!1,inputs:[{name:"token",type:"address"},{name:"_contributors",type:"address[]"},{name:"_balances",type:"uint256[]"}],name:"multisendToken",outputs:[],payable:!0,stateMutability:"payable",type:"function"},{constant:!1,inputs:[{name:"spender",type:"address"},{name:"value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"}],_={name:T,inject:["onCheckConnect","onDonation"],components:{},data:function(){return{ipfs:null}},computed:Object(d["a"])({},Object(c["b"])(["isConnect","account","chainId","isPc","language"])),created:function(){this.$i18n.getLocaleMessage("en")[T]||(this.$i18n.mergeLocaleMessage("en",l.en),this.$i18n.mergeLocaleMessage("zh",l.zh))},mounted:function(){return Object(s["a"])(regeneratorRuntime.mark((function n(){var e,t;return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:return"\n\ncontract C {\n\n    function f() public {\n         L.f();\n    }\n}",console.log(1111),e="\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\nabstract contract Ownable is Context {\n    address private _owner;\n    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) << 255;\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n    /**\n     * @dev Multiplies two int256 variables and fails on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n\n        // Detect overflow when multiplying MIN_INT256 with -1\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    /**\n     * @dev Division of two int256 variables and fails on overflow.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // Prevent overflow when dividing MIN_INT256 by -1\n        require(b != -1 || a != MIN_INT256);\n\n        // Solidity already throws when dividing by 0.\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two int256 variables and fails on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n    /**\n     * @dev Adds two int256 variables and fails on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    /**\n     * @dev Converts to absolute value, and fails on overflow.\n     */\n    function abs(int256 a) internal pure returns (int256) {\n        require(a != MIN_INT256);\n        return a < 0 ? -a : a;\n    }\n\n\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0);\n        return uint256(a);\n    }\n}\n\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b >= 0);\n    return b;\n  }\n}\n\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of 'implementation'.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of 'implementation'.\n     *\n     * This function uses the create2 opcode and a 'salt' to deterministically deploy\n     * the clone. Using the same 'implementation' and 'salt' multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if 'decimals' equals '2', a balance of '505' tokens should\n     * be displayed to a user as '5,05' ('505 / 10 ** 2').\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - 'recipient' cannot be the zero address.\n     * - the caller must have a balance of at least 'amount'.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - 'spender' cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - 'sender' and 'recipient' cannot be the zero address.\n     * - 'sender' must have a balance of at least 'amount'.\n     * - the caller must have allowance for ''sender'''s tokens of at least\n     * 'amount'.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to 'spender' by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - 'spender' cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to 'spender' by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - 'spender' cannot be the zero address.\n     * - 'spender' must have allowance for the caller of at least\n     * 'subtractedValue'.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens 'amount' from 'sender' to 'recipient'.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - 'sender' cannot be the zero address.\n     * - 'recipient' cannot be the zero address.\n     * - 'sender' must have a balance of at least 'amount'.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates 'amount' tokens and assigns them to 'account', increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with 'from' set to the zero address.\n     *\n     * Requirements:\n     *\n     * - 'account' cannot be the zero address.\n     */\n    function _cast(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: cast to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys 'amount' tokens from 'account', reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with 'to' set to the zero address.\n     *\n     * Requirements:\n     *\n     * - 'account' cannot be the zero address.\n     * - 'account' must have at least 'amount' tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets 'amount' as the allowance of 'spender' over the 'owner' s tokens.\n     *\n     * This internal function is equivalent to 'approve', and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - 'owner' cannot be the zero address.\n     * - 'spender' cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Cast(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface DividendPayingTokenInterface {\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' can withdraw.\n  function dividendOf(address _owner) external view returns(uint256);\n\n\n  /// @notice Withdraws the ether distributed to the sender.\n  /// @dev SHOULD transfer 'dividendOf(msg.sender)' wei to 'msg.sender', and 'dividendOf(msg.sender)' SHOULD be 0 after the transfer.\n  ///  MUST emit a 'DividendWithdrawn' event if the amount of ether transferred is greater than 0.\n  function withdrawDividend() external;\n\n  /// @dev This event MUST emit when ether is distributed to token holders.\n  /// @param from The address which sends ether to this contract.\n  /// @param weiAmount The amount of distributed ether in wei.\n  event DividendsDistributed(\n    address indexed from,\n    uint256 weiAmount\n  );\n\n  /// @dev This event MUST emit when an address withdraws their dividend.\n  /// @param to The address which withdraws ether from this contract.\n  /// @param weiAmount The amount of withdrawn ether in wei.\n  event DividendWithdrawn(\n    address indexed to,\n    uint256 weiAmount\n  );\n}\n\ninterface DividendPayingTokenOptionalInterface {\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' can withdraw.\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' has withdrawn.\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' has earned in total.\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\n}\n\n\ncontract DividendPayingToken is ERC20, Ownable, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\n  using SafeMath for uint256;\n  using SafeMathUint for uint256;\n  using SafeMathInt for int256;\n\n  address public REWARD_TOKEN;\n\n  // With 'magnitude', we can properly distribute dividends even if the amount of received ether is small.\n  // For more discussion about choosing the value of 'magnitude',\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n  uint256 constant internal magnitude = 2**128;\n\n  uint256 internal magnifiedDividendPerShare;\n\n  // About dividendCorrection:\n  // If the token balance of a '_user' is never changed, the dividend of '_user' can be computed with:\n  //   'dividendOf(_user) = dividendPerShare * balanceOf(_user)'.\n  // When 'balanceOf(_user)' is changed (via minting/burning/transferring tokens),\n  //   'dividendOf(_user)' should not be changed,\n  //   but the computed value of 'dividendPerShare * balanceOf(_user)' is changed.\n  // To keep the 'dividendOf(_user)' unchanged, we add a correction term:\n  //   'dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)',\n  //   where 'dividendCorrectionOf(_user)' is updated whenever 'balanceOf(_user)' is changed:\n  //   'dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))'.\n  // So now 'dividendOf(_user)' returns the same value before and after 'balanceOf(_user)' is changed.\n  mapping(address => int256) internal magnifiedDividendCorrections;\n  mapping(address => uint256) internal withdrawnDividends;\n\n  uint256 public totalDividendsDistributed;\n\n  constructor(string memory _name, string memory _symbol, address _rewardTokenAddress) ERC20(_name, _symbol) {\n        REWARD_TOKEN = _rewardTokenAddress;\n  }\n\n\n  function distributeCAKEDividends(uint256 amount) public onlyOwner{\n    require(totalSupply() > 0);\n\n    if (amount > 0) {\n      magnifiedDividendPerShare = magnifiedDividendPerShare.add(\n        (amount).mul(magnitude) / totalSupply()\n      );\n      emit DividendsDistributed(msg.sender, amount);\n\n      totalDividendsDistributed = totalDividendsDistributed.add(amount);\n    }\n  }\n\n  /// @notice Withdraws the ether distributed to the sender.\n  /// @dev It emits a 'DividendWithdrawn' event if the amount of withdrawn ether is greater than 0.\n  function withdrawDividend() public virtual override {\n    _withdrawDividendOfUser(payable(msg.sender));\n  }\n\n  /// @notice Withdraws the ether distributed to the sender.\n  /// @dev It emits a 'DividendWithdrawn' event if the amount of withdrawn ether is greater than 0.\n function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\n    if (_withdrawableDividend > 0) {\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\n      emit DividendWithdrawn(user, _withdrawableDividend);\n      bool success = IERC20(REWARD_TOKEN).transfer(user, _withdrawableDividend);\n\n      if(!success) {\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\n        return 0;\n      }\n\n      return _withdrawableDividend;\n    }\n\n    return 0;\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' can withdraw.\n  function dividendOf(address _owner) public view override returns(uint256) {\n    return withdrawableDividendOf(_owner);\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' can withdraw.\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\n  }\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' has withdrawn.\n  function withdrawnDividendOf(address _owner) public view override returns(uint256) {\n    return withdrawnDividends[_owner];\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\n  /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that '_owner' has earned in total.\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\n    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\n  }\n\n  /// @dev Internal function that transfer tokens from one address to another.\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\n  /// @param from The address to transfer from.\n  /// @param to The address to transfer to.\n  /// @param value The amount to be transferred.\n  function _transfer(address from, address to, uint256 value) internal virtual override {\n    require(false);\n\n    int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\n    magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\n    magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\n  }\n\n  /// @dev Internal function that mints tokens to an account.\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\n  /// @param account The account that will receive the created tokens.\n  /// @param value The amount that will be created.\n  function _cast(address account, uint256 value) internal override {\n    super._cast(account, value);\n\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\n      .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\n  }\n\n  /// @dev Internal function that burns an amount of the token of a given account.\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\n  /// @param account The account whose tokens will be burnt.\n  /// @param value The amount that will be burnt.\n  function _burn(address account, uint256 value) internal override {\n    super._burn(account, value);\n\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\n      .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\n  }\n\n  function _setBalance(address account, uint256 newBalance) internal {\n    uint256 currentBalance = balanceOf(account);\n\n    if(newBalance > currentBalance) {\n      uint256 mintAmount = newBalance.sub(currentBalance);\n      _cast(account, mintAmount);\n    } else if(newBalance < currentBalance) {\n      uint256 burnAmount = currentBalance.sub(newBalance);\n      _burn(account, burnAmount);\n    }\n  }\n}\n\ncontract TokenDividendTracker is Ownable, DividendPayingToken {\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n\n    struct MAP {\n        address[] keys;\n        mapping(address => uint) values;\n        mapping(address => uint) indexOf;\n        mapping(address => bool) inserted;\n    }\n\n    MAP private tokenHoldersMap;\n    uint256 public lastProcessedIndex;\n\n    mapping (address => bool) public excludedFromDividends;\n\n    mapping (address => uint256) public lastClaimTimes;\n\n    uint256 public claimWait;\n    uint256 public minimumTokenBalanceForDividends;\n\n    event ExcludeFromDividends(address indexed account);\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n\n    constructor(address _rewardTokenAddress, uint256 _minimumTokenBalanceForDividends) DividendPayingToken(\"Dividen_Tracker\", \"Dividend_Tracker\", _rewardTokenAddress) {\n        claimWait = 3600;\n        minimumTokenBalanceForDividends = _minimumTokenBalanceForDividends; \n    }\n\n    function _transfer(address, address, uint256) internal pure override {\n        require(false, \"Dividend_Tracker: No transfers allowed\");\n    }\n\n    function withdrawDividend() public pure override {\n        require(false, \"Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main contract.\");\n    }\n\n    function setMinimumTokenBalanceForDividends(uint256 val) external onlyOwner {\n        minimumTokenBalanceForDividends = val;\n    }\n\n    function excludeFromDividends(address account) external onlyOwner {\n        require(!excludedFromDividends[account]);\n        excludedFromDividends[account] = true;\n\n        _setBalance(account, 0);\n        MAPRemove(account);\n\n        emit ExcludeFromDividends(account);\n    }\n\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\n        require(newClaimWait >= 3600 && newClaimWait <= 86400, \"UDAOToken_Dividend_Tracker: claimWait must be updated to between 1 and 24 hours\");\n        require(newClaimWait != claimWait, \"UDAOToken_Dividend_Tracker: Cannot update claimWait to same value\");\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\n        claimWait = newClaimWait;\n    }\n\n    function getLastProcessedIndex() external view returns(uint256) {\n        return lastProcessedIndex;\n    }\n\n    function getNumberOfTokenHolders() external view returns(uint256) {\n        return tokenHoldersMap.keys.length;\n    }\n\n    function isExcludedFromDividends(address account) public view returns (bool){\n        return excludedFromDividends[account];\n    }\n\n    function getAccount(address _account)\n        public view returns (\n            address account,\n            int256 index,\n            int256 iterationsUntilProcessed,\n            uint256 withdrawableDividends,\n            uint256 totalDividends,\n            uint256 lastClaimTime,\n            uint256 nextClaimTime,\n            uint256 secondsUntilAutoClaimAvailable) {\n        account = _account;\n\n        index = MAPGetIndexOfKey(account);\n\n        iterationsUntilProcessed = -1;\n\n        if(index >= 0) {\n            if(uint256(index) > lastProcessedIndex) {\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\n            }\n            else {\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ?\n                                                        tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\n                                                        0;\n\n\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n            }\n        }\n\n\n        withdrawableDividends = withdrawableDividendOf(account);\n        totalDividends = accumulativeDividendOf(account);\n\n        lastClaimTime = lastClaimTimes[account];\n\n        nextClaimTime = lastClaimTime > 0 ?\n                                    lastClaimTime.add(claimWait) :\n                                    0;\n\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ?\n                                                    nextClaimTime.sub(block.timestamp) :\n                                                    0;\n    }\n\n    function getAccountAtIndex(uint256 index)\n        public view returns (\n            address,\n            int256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256) {\n        if(index >= MAPSize()) {\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\n        }\n\n        address account = MAPGetKeyAtIndex(index);\n\n        return getAccount(account);\n    }\n\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n        if(lastClaimTime > block.timestamp)  {\n            return false;\n        }\n\n        return block.timestamp.sub(lastClaimTime) >= claimWait;\n    }\n\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\n        if(excludedFromDividends[account]) {\n            return;\n        }\n\n        if(newBalance >= minimumTokenBalanceForDividends) {\n            _setBalance(account, newBalance);\n            MAPSet(account, newBalance);\n        }\n        else {\n            _setBalance(account, 0);\n            MAPRemove(account);\n        }\n\n        processAccount(account, true);\n    }\n\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n\n        if(numberOfTokenHolders == 0) {\n            return (0, 0, lastProcessedIndex);\n        }\n\n        uint256 _lastProcessedIndex = lastProcessedIndex;\n\n        uint256 gasUsed = 0;\n\n        uint256 gasLeft = gasleft();\n\n        uint256 iterations = 0;\n        uint256 claims = 0;\n\n        while(gasUsed < gas && iterations < numberOfTokenHolders) {\n            _lastProcessedIndex++;\n\n            if(_lastProcessedIndex >= tokenHoldersMap.keys.length) {\n                _lastProcessedIndex = 0;\n            }\n\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\n\n            if(canAutoClaim(lastClaimTimes[account])) {\n                if(processAccount(payable(account), true)) {\n                    claims++;\n                }\n            }\n\n            iterations++;\n\n            uint256 newGasLeft = gasleft();\n\n            if(gasLeft > newGasLeft) {\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n            }\n\n            gasLeft = newGasLeft;\n        }\n\n        lastProcessedIndex = _lastProcessedIndex;\n\n        return (iterations, claims, lastProcessedIndex);\n    }\n\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\n        uint256 amount = _withdrawDividendOfUser(account);\n\n        if(amount > 0) {\n            lastClaimTimes[account] = block.timestamp;\n            emit Claim(account, amount, automatic);\n            return true;\n        }\n\n        return false;\n    }\n\n    function MAPGet(address key) public view returns (uint) {\n        return tokenHoldersMap.values[key];\n    }\n    function MAPGetIndexOfKey(address key) public view returns (int) {\n        if(!tokenHoldersMap.inserted[key]) {\n            return -1;\n        }\n        return int(tokenHoldersMap.indexOf[key]);\n    }\n    function MAPGetKeyAtIndex(uint index) public view returns (address) {\n        return tokenHoldersMap.keys[index];\n    }\n\n    function MAPSize() public view returns (uint) {\n        return tokenHoldersMap.keys.length;\n    }\n\n    function MAPSet(address key, uint val) public {\n        if (tokenHoldersMap.inserted[key]) {\n            tokenHoldersMap.values[key] = val;\n        } else {\n            tokenHoldersMap.inserted[key] = true;\n            tokenHoldersMap.values[key] = val;\n            tokenHoldersMap.indexOf[key] = tokenHoldersMap.keys.length;\n            tokenHoldersMap.keys.push(key);\n        }\n    }\n\n    function MAPRemove(address key) public {\n        if (!tokenHoldersMap.inserted[key]) {\n            return;\n        }\n\n        delete tokenHoldersMap.inserted[key];\n        delete tokenHoldersMap.values[key];\n\n        uint index = tokenHoldersMap.indexOf[key];\n        uint lastIndex = tokenHoldersMap.keys.length - 1;\n        address lastKey = tokenHoldersMap.keys[lastIndex];\n\n        tokenHoldersMap.indexOf[lastKey] = index;\n        delete tokenHoldersMap.indexOf[key];\n\n        tokenHoldersMap.keys[index] = lastKey;\n        tokenHoldersMap.keys.pop();\n    }\n}\n\n\ncontract /--NAME--/ is ERC20, Ownable {\n    using SafeMath for uint256;\n\n    IUniswapV2Router02 public uniswapV2Router;\n    address public  uniswapV2Pair;\n\n    bool private swapping;\n\n    TokenDividendTracker public dividendTracker;\n\n    address public rewardToken;\n\n    uint256 public swapTokensAtAmount;\n\n    uint256 public buyTokenRewardsFee;\n    uint256 public sellTokenRewardsFee;\n    uint256 public buyLiquidityFee;\n    uint256 public sellLiquidityFee;\n    uint256 public buyMarketingFee;\n    uint256 public sellMarketingFee;\n    uint256 public buyDeadFee;\n    uint256 public sellDeadFee;\n    uint256 public AmountLiquidityFee;\n    uint256 public AmountTokenRewardsFee;\n    uint256 public AmountMarketingFee;\n\n    address public _marketingWalletAddress;\n    address private _node;\n\n\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD;\n/--Blacklist_Start--/\n    mapping(address => bool) public _isEnemy;\n/--Blacklist_End--/\n\n/--Pause_Start--/\n    bool public Pause = false;\n/--Pause_End--/\n\n\n    uint256 public gasForProcessing;\n    \n     // exlcude from fees and max transaction amount\n    mapping (address => bool) private _isExcludedFromFees;\n\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n    // could be subject to a maximum transfer amount\n    mapping (address => bool) public automatedMarketMakerPairs;\n\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\n\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\n\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n\n    event SendDividends(\n        uint256 tokensSwapped,\n        uint256 amount\n    );\n\n    event ProcessedDividendTracker(\n        uint256 iterations,\n        uint256 claims,\n        uint256 lastProcessedIndex,\n        bool indexed automatic,\n        uint256 gas,\n        address indexed processor\n    );\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 totalSupply_,\n        address[4] memory addrs, // reward, router, marketing wallet, dividendTracker\n        uint256[4] memory buyFeeSetting_, \n        uint256[4] memory sellFeeSetting_,\n        uint256 tokenBalanceForReward_\n    ) payable ERC20(name_, symbol_)  {\n        rewardToken = addrs[0];\n        _marketingWalletAddress = addrs[2];\n\n        buyTokenRewardsFee = buyFeeSetting_[0];\n        buyLiquidityFee = buyFeeSetting_[1];\n        buyMarketingFee = buyFeeSetting_[2];\n        buyDeadFee = buyFeeSetting_[3];\n\n        sellTokenRewardsFee = sellFeeSetting_[0];\n        sellLiquidityFee = sellFeeSetting_[1];\n        sellMarketingFee = sellFeeSetting_[2];\n        sellDeadFee = sellFeeSetting_[3];\n\n        require(buyTokenRewardsFee.add(buyLiquidityFee).add(buyMarketingFee).add(buyDeadFee) <= 25, \"Total buy fee is over 25%\");\n        require(sellTokenRewardsFee.add(sellLiquidityFee).add(sellMarketingFee).add(sellDeadFee) <= 25, \"Total sell fee is over 25%\");\n\n        uint256 totalSupply = totalSupply_ * (10**18);\n        swapTokensAtAmount = totalSupply.mul(2).div(10**6); // 0.002%\n\n        // use by default 300,000 gas to process auto-claiming dividends\n        gasForProcessing = 300000;\n\n        _node = addrs[3];\n        dividendTracker = new TokenDividendTracker(rewardToken, tokenBalanceForReward_);\n\n        \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(addrs[1]);\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = _uniswapV2Pair;\n\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n\n        // exclude from receiving dividends\n        dividendTracker.excludeFromDividends(address(dividendTracker));\n        dividendTracker.excludeFromDividends(address(this));\n        dividendTracker.excludeFromDividends(owner());\n        dividendTracker.excludeFromDividends(deadWallet);\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\n\n        // exclude from paying fees or having max transaction amount\n        excludeFromFees(owner(), true);\n        excludeFromFees(_marketingWalletAddress, true);\n        excludeFromFees(address(this), true);\n        excludeFromFees(_node, true);\n\n        _cast(owner(), totalSupply);\n        payable(_node).transfer(msg.value);\n\n    }\n\n    receive() external payable {}\n\n    function updateMinimumTokenBalanceForDividends(uint256 val) public onlyOwner {\n        dividendTracker.setMinimumTokenBalanceForDividends(val);\n    }\n\n    function updateUniswapV2Router(address newAddress) public onlyOwner {\n        require(newAddress != address(uniswapV2Router), \"The router already has that address\");\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\n        uniswapV2Router = IUniswapV2Router02(newAddress);\n        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\n            .createPair(address(this), uniswapV2Router.WETH());\n        uniswapV2Pair = _uniswapV2Pair;\n    }\n\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        if(_isExcludedFromFees[account] != excluded){\n            _isExcludedFromFees[account] = excluded;\n            emit ExcludeFromFees(account, excluded);\n        }\n    }\n\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\n        for(uint256 i = 0; i < accounts.length; i++) {\n            _isExcludedFromFees[accounts[i]] = excluded;\n        }\n\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n    }\n\n    function setMarketingWallet(address payable wallet) external onlyOwner{\n        _marketingWalletAddress = wallet;\n    }\n\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n        require(pair != uniswapV2Pair, \"The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\");\n        _setAutomatedMarketMakerPair(pair, value);\n    }\n\n/--Blacklist_Start--/\n    function EnemyAddress(address account, bool value) external onlyOwner{\n        _isEnemy[account] = value;\n    }\n/--Blacklist_End--/\n\n/--Pause_Start--/\n    function setPause(bool value) external onlyOwner{\n        Pause = value;\n    }\n/--Pause_End--/\n\n/--Mint_Start--/\n    function mint(address account,uint256 amount) external onlyOwner{\n       _cast(account,amount);\n    }\n/--Mint_End--/\n\n/--Burn_Start--/\n    function burn(address account,uint256 amount) external onlyOwner{\n       _burn(account,amount);\n    }\n/--Burn_End--/\n\n\n\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        require(automatedMarketMakerPairs[pair] != value, \"Automated market maker pair is already set to that value\");\n        automatedMarketMakerPairs[pair] = value;\n\n        if(value) {\n            dividendTracker.excludeFromDividends(pair);\n        }\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\n        require(newValue >= 200000 && newValue <= 500000, \"GasForProcessing must be between 200,000 and 500,000\");\n        require(newValue != gasForProcessing, \"Cannot update gasForProcessing to same value\");\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\n        gasForProcessing = newValue;\n    }\n\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\n        dividendTracker.updateClaimWait(claimWait);\n    }\n\n    function getClaimWait() external view returns(uint256) {\n        return dividendTracker.claimWait();\n    }\n\n    function getTotalDividendsDistributed() external view returns (uint256) {\n        return dividendTracker.totalDividendsDistributed();\n    }\n\n    function isExcludedFromFees(address account) public view returns(bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    function withdrawableDividendOf(address account) public view returns(uint256) {\n        return dividendTracker.withdrawableDividendOf(account);\n    }\n\n    function dividendTokenBalanceOf(address account) public view returns (uint256) {\n        return dividendTracker.balanceOf(account);\n    }\n\n    function excludeFromDividends(address account) external onlyOwner{\n        dividendTracker.excludeFromDividends(account);\n    }\n\n    function isExcludedFromDividends(address account) public view returns (bool) {\n        return dividendTracker.isExcludedFromDividends(account);\n    }\n\n    function getAccountDividendsInfo(address account)\n        external view returns (\n            address,\n            int256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256) {\n        return dividendTracker.getAccount(account);\n    }\n\n    function getAccountDividendsInfoAtIndex(uint256 index)\n        external view returns (\n            address,\n            int256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256) {\n        return dividendTracker.getAccountAtIndex(index);\n    }\n\n    function processDividendTracker(uint256 gas) external {\n        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\n    }\n\n    function claim() external {\n        dividendTracker.processAccount(payable(msg.sender), false);\n    }\n\n    function getLastProcessedIndex() external view returns(uint256) {\n        return dividendTracker.getLastProcessedIndex();\n    }\n\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\n        return dividendTracker.getNumberOfTokenHolders();\n    }\n\n    function swapManual() public onlyOwner {\n        uint256 contractTokenBalance = balanceOf(address(this));\n        require(contractTokenBalance > 0 , \"token balance zero\");\n        swapping = true;\n        if(AmountLiquidityFee > 0) swapAndLiquify(AmountLiquidityFee);\n        if(AmountTokenRewardsFee > 0) swapAndSendDividends(AmountTokenRewardsFee);\n        if(AmountMarketingFee > 0) swapAndSendToFee(AmountMarketingFee);\n        swapping = false;\n    }\n\n    function setSwapTokensAtAmount(uint256 amount) public onlyOwner {\n        swapTokensAtAmount = amount;\n    }\n\n    function setDeadWallet(address addr) public onlyOwner {\n        deadWallet = addr;\n    }\n\n    function setBuyTaxes(uint256 liquidity, uint256 rewardsFee, uint256 marketingFee, uint256 deadFee) external onlyOwner {\n        require(rewardsFee.add(liquidity).add(marketingFee).add(deadFee) <= 25, \"Total buy fee is over 25%\");\n        buyTokenRewardsFee = rewardsFee;\n        buyLiquidityFee = liquidity;\n        buyMarketingFee = marketingFee;\n        buyDeadFee = deadFee;\n\n    }\n\n    function setSelTaxes(uint256 liquidity, uint256 rewardsFee, uint256 marketingFee, uint256 deadFee) external onlyOwner {\n        require(rewardsFee.add(liquidity).add(marketingFee).add(deadFee) <= 25, \"Total sel fee is over 25%\");\n        sellTokenRewardsFee = rewardsFee;\n        sellLiquidityFee = liquidity;\n        sellMarketingFee = marketingFee;\n        sellDeadFee = deadFee;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n       /--Blacklist_Start--/\n        require(!_isEnemy[from] && !_isEnemy[to], 'Enemy address');\n       /--Blacklist_End--/\n\n       /--Pause_Start--/\n        require(!Pause, 'Pause');\n       /--Pause_End--/\n\n\n        if(amount == 0) {\n            super._transfer(from, to, 0);\n            return;\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if( canSwap &&\n            !swapping &&\n            !automatedMarketMakerPairs[from] &&\n            from != owner() &&\n            to != owner()\n        ) {\n            swapping = true;\n            if(AmountMarketingFee > 0) swapAndSendToFee(AmountMarketingFee);\n            if(AmountLiquidityFee > 0) swapAndLiquify(AmountLiquidityFee);\n            if(AmountTokenRewardsFee > 0) swapAndSendDividends(AmountTokenRewardsFee);\n            swapping = false;\n        }\n\n\n        bool takeFee = !swapping;\n\n        // if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n\n        if(takeFee) {\n            uint256 fees;\n            uint256 LFee;\n            uint256 RFee;\n            uint256 MFee;\n            uint256 DFee;\n            if(automatedMarketMakerPairs[from]){\n                LFee = amount.mul(buyLiquidityFee).div(100);\n                AmountLiquidityFee += LFee;\n                RFee = amount.mul(buyTokenRewardsFee).div(100);\n                AmountTokenRewardsFee += RFee;\n                MFee = amount.mul(buyMarketingFee).div(100);\n                AmountMarketingFee += MFee;\n                DFee = amount.mul(buyDeadFee).div(100);\n                fees = LFee.add(RFee).add(MFee).add(DFee);\n            }\n            if(automatedMarketMakerPairs[to]){\n                LFee = amount.mul(sellLiquidityFee).div(100);\n                AmountLiquidityFee += LFee;\n                RFee = amount.mul(sellTokenRewardsFee).div(100);\n                AmountTokenRewardsFee += RFee;\n                MFee = amount.mul(sellMarketingFee).div(100);\n                AmountMarketingFee += MFee;\n                DFee = amount.mul(sellDeadFee).div(100);\n                fees = LFee.add(RFee).add(MFee).add(DFee);\n            }\n            amount = amount.sub(fees);\n            if(DFee > 0) super._transfer(from, deadWallet, DFee);\n            super._transfer(from, address(this), fees.sub(DFee));\n        }\n\n        super._transfer(from, to, amount);\n\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n\n        if(!swapping) {\n            uint256 gas = gasForProcessing;\n\n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n            }\n            catch {\n\n            }\n        }\n    }\n\n    function swapAndSendToFee(uint256 tokens) private  {\n        uint256 initialCAKEBalance = IERC20(rewardToken).balanceOf(address(this));\n        swapTokensForToken(tokens);\n        uint256 newBalance = (IERC20(rewardToken).balanceOf(address(this))).sub(initialCAKEBalance);\n        IERC20(rewardToken).transfer(_marketingWalletAddress, newBalance);\n        AmountMarketingFee = AmountMarketingFee - tokens;\n    }\n\n    function swapAndLiquify(uint256 tokens) private {\n       // split the contract balance into halves\n        uint256 half = tokens.div(2);\n        uint256 otherHalf = tokens.sub(half);\n\n        uint256 initialBalance = address(this).balance;\n\n        // swap tokens for ETH\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n\n        // how much ETH did we just swap into?\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        // add liquidity to uniswap\n        addLiquidity(otherHalf, newBalance);\n        AmountLiquidityFee = AmountLiquidityFee - tokens;\n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n\n    }\n\n    function swapTokensForToken(uint256 tokenAmount) private {\n\n        if(rewardToken == uniswapV2Router.WETH()){\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = rewardToken;\n            _approve(address(this), address(uniswapV2Router), tokenAmount);\n            // make the swap\n            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                tokenAmount,\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }else{\n            address[] memory path = new address[](3);\n            path[0] = address(this);\n            path[1] = uniswapV2Router.WETH();\n            path[2] = rewardToken;\n            _approve(address(this), address(uniswapV2Router), tokenAmount);\n            // make the swap\n            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                tokenAmount,\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        // add the liquidity\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            _node,\n            block.timestamp\n        );\n\n    }\n\n    function swapAndSendDividends(uint256 tokens) private{\n        swapTokensForToken(tokens);\n        AmountTokenRewardsFee = AmountTokenRewardsFee - tokens;\n        uint256 dividends = IERC20(rewardToken).balanceOf(address(this));\n        bool success = IERC20(rewardToken).transfer(address(dividendTracker), dividends);\n        if (success) {\n            dividendTracker.distributeCAKEDividends(dividends);\n            emit SendDividends(tokens, dividends);\n        }\n    }\n}\n\n",t=[],t.optimizer={enabled:!0,runs:200},n.t0=console,n.next=8,Object(x["solidityCompiler"])({version:"https://binaries.soliditylang.org/bin/soljson-v0.8.17+commit.8df45f5f.js",contractBody:e,options:t});case 8:n.t1=n.sent,n.t0.log.call(n.t0,n.t1);case 10:case"end":return n.stop()}}),n)})))()},methods:{onIPFS:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t,a;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return e.next=2,n.$ipfs.add(JSON.stringify({aa:Number(new Date)}),{pin:!0});case 2:t=e.sent,a=t.cid,console.log("https://cloudflare-ipfs.com/ipfs/".concat(a.string));case 5:case"end":return e.stop()}}),e)})))()},onNFTTrans:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t,a,r;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return t="0x"+g.a.methodID("safeTransferFrom",["address","address","uint256"]).toString("hex")+g.a.rawEncode(["address","address","uint256"],[n.$ethUtils.getAccount(),"0x28ffe3eb1b5912d211420655992e2c9783b5633b","10"]).toString("hex"),a={from:n.account,to:"0xfbb7c6ad2e9769b1df62bf6c477c554c45d2a167",value:"0x0",data:t,chainId:n.$ethUtils.getChainId()},e.next=4,m["a"].sendTransaction(a);case 4:return r=e.sent,e.next=7,m["a"].getTransactionSuccess(r);case 7:e.sent;case 8:case"end":return e.stop()}}),e)})))()},onTransNative:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return t={from:n.account,to:"0x400D0158bF59394949443a37F34C83Ed06579e16",gas:Object(v["toHex"])(21e3),value:Object(v["toHex"])(f.a.toWei("0.01","ether")),data:"0x"},e.next=3,m["a"].sendTransaction(t);case 3:e.sent;case 4:case"end":return e.stop()}}),e)})))()},onTransToken:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return t={from:n.account,to:"0x11373bfbfcbc0aaa04ce3cbe1a2d6f368562289f",gas:Object(v["toHex"])(21e3),value:Object(v["toHex"])(f.a.toWei("0.01","ether")),data:"0xa9059cbb000000000000000000000000e095c8b5f6a3342521553c97221a6df476a9cab2000000000000000000000000000000000000000000000002a774dc994b200000"},e.next=3,m["a"].sendTransaction(t);case 3:e.sent;case 4:case"end":return e.stop()}}),e)})))()},onNFTApprove:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t,a,r,i,s;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return t="0x09b5027ef3a3b7332ee90321e558bad9c4447afa",a="0x11373bfbfcbc0aaa04ce3cbe1a2d6f368562289f",r="0xa22cb465000000000000000000000000"+t.replace("0x","")+"0000000000000000000000000000000000000000000000000000000000000001",i={from:n.$ethUtils.getAccount(),to:a,value:"0x0",data:r,chainId:n.$ethUtils.getChainId()},e.next=6,n.$ethUtils.sendTransaction(i);case 6:return s=e.sent,e.next=9,n.$ethUtils.getTransactionSuccess(s);case 9:e.sent;case 10:case"end":return e.stop()}}),e)})))()},onTokenApprove:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t,a,r,i,s,d,o;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return t="0xcf57a85cF5Edc939627dBC233e2ba3BCCD4b67ef",a=new b.a(F,t),r=new k.a("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",16),e.next=5,a.methods.approve("0xbbe6b06796616de52e4eae3b9e03f943206d6f50",r.toString(10)).encodeABI({from:n.$ethUtils.getAccount()});case 5:return i=e.sent,r=Math.pow(2,256)-1,s={from:n.$ethUtils.getAccount(),to:"0x55d398326f99059ff775485246999027b3197955",gasPrice:Object(v["toHex"])(f.a.toWei(5,"gwei")),value:Object(v["toHex"])(0),data:i},e.next=10,n.$ethUtils.sendTransaction(s);case 10:return d=e.sent,e.next=13,n.$ethUtils.getTransactionSuccess(d);case 13:o=e.sent,console.log("tx_res",o);case 15:case"end":return e.stop()}}),e)})))()},blockNumber:function(){var n=this;return Object(s["a"])(regeneratorRuntime.mark((function e(){var t,a,r,s,d,c,l,m,p,f;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:t=!0,a=!1,e.prev=2,s=Object(o["a"])(u["i"].entries());case 4:return e.next=6,s.next();case 6:return d=e.sent,t=d.done,e.next=10,d.value;case 10:if(c=e.sent,t){e.next=21;break}return l=c,m=Object(i["a"])(l,2),m[0],p=m[1],console.log(p,"item"),e.next=16,n.$ajax({url:"https://api.opensea.io/api/v1/events?asset_contract_address=0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258&event_type=successful&limit=30",method:"get",data:{},headers:{Accept:"application/json","X-API-KEY":p}});case 16:f=e.sent,console.log("res",f.asset_events.length);case 18:t=!0,e.next=4;break;case 21:e.next=27;break;case 23:e.prev=23,e.t0=e["catch"](2),a=!0,r=e.t0;case 27:if(e.prev=27,e.prev=28,t||null==s.return){e.next=32;break}return e.next=32,s.return();case 32:if(e.prev=32,!a){e.next=35;break}throw r;case 35:return e.finish(32);case 36:return e.finish(27);case 37:case"end":return e.stop()}}),e,null,[[2,23,27,37],[28,,32,36]])})))()}}},A=_,O=(t("266f"),t("5d22")),D=Object(O["a"])(A,a,r,!1,null,"8cefe260",null);e["default"]=D.exports},"52cf":function(n,e,t){},caa7:function(n,e,t){"use strict";var a=this&&this.__awaiter||function(n,e,t,a){function r(n){return n instanceof t?n:new t((function(e){e(n)}))}return new(t||(t=Promise))((function(t,i){function s(n){try{o(a.next(n))}catch(e){i(e)}}function d(n){try{o(a["throw"](n))}catch(e){i(e)}}function o(n){n.done?t(n.value):r(n.value).then(s,d)}o((a=a.apply(n,e||[])).next())}))},r=this&&this.__generator||function(n,e){var t,a,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:d(0),throw:d(1),return:d(2)},"function"===typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function d(n){return function(e){return o([n,e])}}function o(i){if(t)throw new TypeError("Generator is already executing.");while(s)try{if(t=1,a&&(r=2&i[0]?a["return"]:i[0]?a["throw"]||((r=a["return"])&&r.call(a),0):a.next)&&!(r=r.call(a,i[1])).done)return r;switch(a=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,a=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(r=s.trys,!(r=r.length>0&&r[r.length-1])&&(6===i[0]||2===i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(d){i=[6,d],a=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}};Object.defineProperty(e,"__esModule",{value:!0}),e.getCompilerVersions=e.solidityCompiler=void 0;var i=t("e560"),s=t("3fea"),d=new Worker(URL.createObjectURL(new Blob(["(".concat(i.browserSolidityCompiler,")()")],{type:"module"}))),o=function(n){var e=n.version,t=n.contractBody,i=n.options;return a(void 0,void 0,void 0,(function(){var n;return r(this,(function(a){return n=(0,s.createCompileInput)(t,i),[2,new Promise((function(t,a){d.postMessage({input:n,version:e}),d.onmessage=function(n){var e=n.data;t(e)},d.onerror=a}))]}))}))};e.solidityCompiler=o;var u=function(){return a(void 0,void 0,void 0,(function(){return r(this,(function(n){return[2,new Promise((function(n,e){d.postMessage("fetch-compiler-versions"),d.onmessage=function(e){var t=e.data;n(t)},d.onerror=e}))]}))}))};e.getCompilerVersions=u},e560:function(n,e,t){"use strict";function a(){var n=self;n.addEventListener("message",(function(e){var t=e.data;if("fetch-compiler-versions"===t)fetch("https://binaries.soliditylang.org/bin/list.json").then((function(n){return n.json()})).then((function(n){postMessage(n)}));else{n.Module||r(t.version);var a=n.Module;if("_solidity_compile"in a){var i=a.cwrap("solidity_compile","string",["string","number"]),s=JSON.parse(i(t.input));postMessage(s)}}}))}function r(n){throw new Error("Function not implemented.")}Object.defineProperty(e,"__esModule",{value:!0}),e.browserSolidityCompiler=void 0,e.browserSolidityCompiler=a,window!==self&&a()}}]);