(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-commons"],{"0061":function(e,n,t){"use strict";t("2b4c")},"0455":function(e,n,t){},"0e80":function(e,n,t){},"12f9":function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticStyle:{width:"100%",height:"100%",position:"relative"}},[t("CodeReviewDialog",{ref:"CodeReviewDialog",attrs:{title:e.$t("createTokenCard.codeReviewDialogTitle")}}),t("div",{staticClass:"card"},[t("div",{class:{left:!0,showText:"tokenAdmin"===e.$route.name}},[t("div",{staticClass:"codeView",on:{click:e.onShowCodeView}},[t("svg-icon",{staticClass:"icon",attrs:{"icon-class":"code"}})],1),e.isCreateToken?t("ChangeChainBox",{ref:"ChangeChainBox"}):t("svg-icon",{staticClass:"coinIcon",attrs:{"icon-class":e.icon}}),t("h1",[e._v(e._s(e.title))]),t("p",{staticClass:"desc"},[e._v(e._s(e.desc))]),t("p",{staticClass:"desc"},[e._v(e._s(e.$t("createTokenCard.no_code")))]),t("p",{staticClass:"desc"},[e._v(e._s(e.$t("createTokenCard.you_onwer")))]),t("p",{staticClass:"desc"},[e._v(e._s(e.$t("createTokenCard.token_custom")))]),t("p",{staticClass:"desc"},[e._v(e._s(e.$t("createTokenCard.open_opensource")))]),t("div",{staticClass:"bottomBtn"},[e.isShowPresaleList&&!e.isZh?t("el-button",{attrs:{type:"primary",plain:""},on:{click:e.onGoPresaleList}},[e._v(e._s(e.$t("route.presaleList")))]):e._e(),e.isShowAdminBtn?t("el-button",{attrs:{type:"success",plain:""},on:{click:e.onGoTokenAdmin}},[e._v(e._s(e.$t("createTokenCard.token_admin")))]):e._e()],1)],1),t("div",{staticClass:"right"},[t("div",{staticClass:"rightBox"},[e._t("default")],2)])]),t("div",{directives:[{name:"show",rawName:"v-show",value:"zh"===e.language,expression:"language === 'zh'"}],staticClass:"tips"},[e._v(e._s(e.$t("createTokenCard.tips")))])],1)},a=[],i=t("efe2"),s=(t("65f0"),t("37de"),t("1e34"),t("dfe9"),t("403f"),t("297b"),t("52c1")),o={zh:{createTokenCard:{no_code:"无需任何编程技能",you_onwer:"百分百拥有代币的所有权",token_custom:"自定义代币名称、符号、发行量等",token_admin:"代币管理",open_opensource:"代币合约源代码自动发布和验证通过",tips:"本工具只用于区块链学习测试，如用于违法活动，与本站无关",changeChainDialogTitle:"切换创建Token",codeReviewDialogTitle:"合约源代码"}},en:{createTokenCard:{no_code:"No programming skills required",you_onwer:"Get 100% ownership of generated tokens",token_admin:"Token Admin",token_custom:"Custom token name, symbol and initial supply",open_opensource:"Automatic verified and published contract source code",tips:"",changeChainDialogTitle:"Change Create Token",codeReviewDialogTitle:"Contract source code"}}},u=t("3135"),d=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"ChangeChainBox"},[t("ul",e._l(e.list,(function(n,r){return t("li",{key:r,class:{on:e.chainName===n},on:{click:function(t){return e.onSelect(n)}}},[t("svg-icon",{staticClass:"icon",style:{color:e.$coinInfo[n].color?e.$coinInfo[n].color:""},attrs:{"icon-class":e.$coinInfo[n].icon}}),t("span",{staticClass:"name"},[e._v(e._s(e.$coinInfo[n].chainName)+" ")])],1)})),0)])},c=[],l=t("4833"),p=(t("6a61"),t("8b79"),t("5a50")),m={components:{},props:{},data:function(){return{list:[],loading:!0,isShowDialog:!1,chainName:""}},computed:Object(i["a"])({},Object(s["b"])(["isPc"])),created:function(){this.list=p["b"][this.$route.name],this.chainName=this.$route.path.replace("/".concat(this.$route.name,"/"),"").replace("/","")},mounted:function(){},methods:{onSelect:function(e){e!==this.chainName&&(this.show(),this.$router.push({path:"/".concat(this.$route.name,"/").concat(e),query:this.$route.query}))},show:function(){var e=this;return Object(l["a"])(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:e.isShowDialog=!e.isShowDialog;case 1:case"end":return n.stop()}}),n)})))()}}},f=m,h=(t("7dc2"),t("5d22")),w=Object(h["a"])(f,d,c,!1,null,"b9be0864",null),v=w.exports,_="createTokenCard",b={name:"Card",components:{CodeReviewDialog:u["a"],ChangeChainBox:v},props:{isCreateToken:{type:Boolean,default:!0},isShowAdminBtn:{type:Boolean,default:!0},icon:{type:String,default:"coin-eth2"},title:{type:String,default:"title"},desc:{type:String,default:""},createType:{type:Number,default:0}},data:function(){return{isIframe:!1,chainName:"",isShowPresaleList:!1}},computed:Object(i["a"])({},Object(s["b"])(["language","isZh"])),created:function(){this.$i18n.getLocaleMessage("en")[_]||(this.$i18n.mergeLocaleMessage("en",o.en),this.$i18n.mergeLocaleMessage("zh",o.zh)),this.chainName=this.$route.path.replace("/".concat(this.$route.name,"/"),"").replace("/",""),"createPresale"===this.$route.name&&(this.isShowPresaleList=!0)},mounted:function(){},methods:{onGoPresaleList:function(){p["b"]["presaleList"].includes(this.chainName)?this.$router.push({path:"/presaleList/".concat(this.chainName)}):this.$router.push({path:"/presaleList"})},onShowCodeView:function(){this.$refs.CodeReviewDialog.show()},onGoTokenAdmin:function(){this.$router.push({name:"tokenAdmin",query:{createType:this.createType}})}}},y=b,g=(t("ff09"),Object(h["a"])(y,r,a,!1,null,"502ff6eb",null));n["a"]=g.exports},"18ac":function(e,n,t){},"1a9e":function(e,n,t){"use strict";t("745c")},"1ce7":function(e,n,t){},"1dab":function(e,n,t){},"24b4":function(e,n,t){"use strict";t("655a")},"2b4c":function(e,n,t){},3135:function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("el-dialog",{attrs:{width:e.isPc?"800px":"90%",visible:e.isShowDialog,center:""},on:{"update:visible":function(n){e.isShowDialog=n}}},[t("div",{staticClass:"title",attrs:{slot:"title"},slot:"title"},[t("p",[e._v(e._s(e.title))]),t("svg-icon",{staticClass:"icon",attrs:{"icon-class":"code"}})],1),t("div",{staticClass:"dialogBox"},[t("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs",value:e.sourcecode,expression:"sourcecode"}]},[t("code",{staticClass:"javascript"})])]),t("span",{staticClass:"dialog-footer",attrs:{slot:"footer"},slot:"footer"},[t("el-button",{directives:[{name:"clipboard",rawName:"v-clipboard:copy",value:e.sourcecode,expression:"sourcecode",arg:"copy"},{name:"clipboard",rawName:"v-clipboard:success",value:e.onCopySuccess,expression:"onCopySuccess",arg:"success"}],attrs:{type:"primary",size:"large"}},[t("svg-icon",{attrs:{"icon-class":"copy"}}),e._v(" "+e._s(e.$t("common.copy"))+" ")],1)],1)])},a=[],i=t("4833"),s=t("efe2"),o=(t("6a61"),t("f597"),{code:'\n  pragma solidity ^0.8.4;\n  // SPDX-License-Identifier: Unlicensed\n  interface IERC20 {\n  \n      function totalSupply() external view returns (uint256);\n  \n \n      function balanceOf(address account) external view returns (uint256);\n  \n\n      function transfer(address recipient, uint256 amount) external returns (bool);\n  \n\n      function allowance(address owner, address spender) external view returns (uint256);\n\n      function approve(address spender, uint256 amount) external returns (bool);\n\n      function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  \n\n      event Transfer(address indexed from, address indexed to, uint256 value);\n  \n\n      event Approval(address indexed owner, address indexed spender, uint256 value);\n  }\n\n   \n  library SafeMath {\n\n      function add(uint256 a, uint256 b) internal pure returns (uint256) {\n          uint256 c = a + b;\n          require(c >= a, "SafeMath: addition overflow");\n  \n          return c;\n      }\n  \n\n      function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n          return sub(a, b, "SafeMath: subtraction overflow");\n      }\n\n      function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n          require(b <= a, errorMessage);\n          uint256 c = a - b;\n  \n          return c;\n      }\n  \n\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n          // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n          // benefit is lost if \'b\' is also tested.\n          // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n          if (a == 0) {\n              return 0;\n          }\n  \n          uint256 c = a * b;\n          require(c / a == b, "SafeMath: multiplication overflow");\n  \n          return c;\n      }\n  \n\n      function div(uint256 a, uint256 b) internal pure returns (uint256) {\n          return div(a, b, "SafeMath: division by zero");\n      }\n\n      function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n          require(b > 0, errorMessage);\n          uint256 c = a / b;\n          // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\n  \n          return c;\n      }\n  \n\n      function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n          return mod(a, b, "SafeMath: modulo by zero");\n      }\n  \n\n      function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n          require(b != 0, errorMessage);\n          return a % b;\n      }\n  }\n  \n  abstract contract Context {\n      function _msgSender() internal view virtual returns (address payable) {\n          return msg.sender;\n      }\n  \n      function _msgData() internal view virtual returns (bytes memory) {\n          this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n          return msg.data;\n      }\n  }\n  \n  \n  /**\n   * @dev Collection of functions related to the address type\n   */\n  library Address {\n\n      function isContract(address account) internal view returns (bool) {\n          bytes32 codehash;\n          bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n          // solhint-disable-next-line no-inline-assembly\n          assembly { codehash := extcodehash(account) }\n          return (codehash != accountHash && codehash != 0x0);\n      }\n\n      function sendValue(address payable recipient, uint256 amount) internal {\n          require(address(this).balance >= amount, "Address: insufficient balance");\n  \n          // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n          (bool success, ) = recipient.call{ value: amount }("");\n          require(success, "Address: unable to send value, recipient may have reverted");\n      }\n  \n\n      function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, "Address: low-level call failed");\n      }\n\n      function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n          return _functionCallWithValue(target, data, 0, errorMessage);\n      }\n  \n\n      function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n          return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n      }\n  \n \n      function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n          require(address(this).balance >= value, "Address: insufficient balance for call");\n          return _functionCallWithValue(target, data, value, errorMessage);\n      }\n  \n      function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n          require(isContract(target), "Address: call to non-contract");\n  \n          // solhint-disable-next-line avoid-low-level-calls\n          (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n          if (success) {\n              return returndata;\n          } else {\n              // Look for revert reason and bubble it up if present\n              if (returndata.length > 0) {\n                  // The easiest way to bubble the revert reason is using memory via assembly\n  \n                  // solhint-disable-next-line no-inline-assembly\n                  assembly {\n                      let returndata_size := mload(returndata)\n                      revert(add(32, returndata), returndata_size)\n                  }\n              } else {\n                  revert(errorMessage);\n              }\n          }\n      }\n  }\n  \n\n  contract Ownable is Context {\n      address private _owner;\n      address private _previousOwner;\n      uint256 private _lockTime;\n  \n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  \n      /**\n       * @dev Initializes the contract setting the deployer as the initial owner.\n       */\n      constructor () internal {\n          address msgSender = _msgSender();\n          _owner = msgSender;\n          emit OwnershipTransferred(address(0), msgSender);\n      }\n  \n      /**\n       * @dev Returns the address of the current owner.\n       */\n      function owner() public view returns (address) {\n          return _owner;\n      }\n  \n      /**\n       * @dev Throws if called by any account other than the owner.\n       */\n      modifier onlyOwner() {\n          require(_owner == _msgSender(), "Ownable: caller is not the owner");\n          _;\n      }\n\n      function renounceOwnership() public virtual onlyOwner {\n          emit OwnershipTransferred(_owner, address(0));\n          _owner = address(0);\n      }\n  \n\n      function transferOwnership(address newOwner) public virtual onlyOwner {\n          require(newOwner != address(0), "Ownable: new owner is the zero address");\n          emit OwnershipTransferred(_owner, newOwner);\n          _owner = newOwner;\n      }\n  \n      function geUnlockTime() public view returns (uint256) {\n          return _lockTime;\n      }\n  \n      //Locks the contract for owner for the amount of time provided\n      function lock(uint256 time) public virtual onlyOwner {\n          _previousOwner = _owner;\n          _owner = address(0);\n          _lockTime = now + time;\n          emit OwnershipTransferred(_owner, address(0));\n      }\n      \n      //Unlocks the contract for owner when _lockTime is exceeds\n      function unlock() public virtual {\n          require(_previousOwner == msg.sender, "You don\'t have permission to unlock");\n          require(now > _lockTime , "Contract is locked until 7 days");\n          emit OwnershipTransferred(_owner, _previousOwner);\n          _owner = _previousOwner;\n      }\n  }\n  \n  // pragma solidity >=0.5.0;\n  \n  interface IUniswapV2Factory {\n      event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n  \n      function feeTo() external view returns (address);\n      function feeToSetter() external view returns (address);\n  \n      function getPair(address tokenA, address tokenB) external view returns (address pair);\n      function allPairs(uint) external view returns (address pair);\n      function allPairsLength() external view returns (uint);\n  \n      function createPair(address tokenA, address tokenB) external returns (address pair);\n  \n      function setFeeTo(address) external;\n      function setFeeToSetter(address) external;\n  }\n  \n  \n  // pragma solidity >=0.5.0;\n  \n  interface IUniswapV2Pair {\n      event Approval(address indexed owner, address indexed spender, uint value);\n      event Transfer(address indexed from, address indexed to, uint value);\n  \n      function name() external pure returns (string memory);\n      function symbol() external pure returns (string memory);\n      function decimals() external pure returns (uint8);\n      function totalSupply() external view returns (uint);\n      function balanceOf(address owner) external view returns (uint);\n      function allowance(address owner, address spender) external view returns (uint);\n  \n      function approve(address spender, uint value) external returns (bool);\n      function transfer(address to, uint value) external returns (bool);\n      function transferFrom(address from, address to, uint value) external returns (bool);\n  \n      function DOMAIN_SEPARATOR() external view returns (bytes32);\n      function PERMIT_TYPEHASH() external pure returns (bytes32);\n      function nonces(address owner) external view returns (uint);\n  \n      function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n  \n      event Mint(address indexed sender, uint amount0, uint amount1);\n      event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n      event Swap(\n          address indexed sender,\n          uint amount0In,\n          uint amount1In,\n          uint amount0Out,\n          uint amount1Out,\n          address indexed to\n      );\n      event Sync(uint112 reserve0, uint112 reserve1);\n  \n      function MINIMUM_LIQUIDITY() external pure returns (uint);\n      function factory() external view returns (address);\n      function token0() external view returns (address);\n      function token1() external view returns (address);\n      function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n      function price0CumulativeLast() external view returns (uint);\n      function price1CumulativeLast() external view returns (uint);\n      function kLast() external view returns (uint);\n  \n      function mint(address to) external returns (uint liquidity);\n      function burn(address to) external returns (uint amount0, uint amount1);\n      function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n      function skim(address to) external;\n      function sync() external;\n  \n      function initialize(address, address) external;\n  }\n  \n  // pragma solidity >=0.6.2;\n  \n  interface IUniswapV2Router01 {\n      function factory() external pure returns (address);\n      function WETH() external pure returns (address);\n  \n      function addLiquidity(\n          address tokenA,\n          address tokenB,\n          uint amountADesired,\n          uint amountBDesired,\n          uint amountAMin,\n          uint amountBMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountA, uint amountB, uint liquidity);\n      function addLiquidityETH(\n          address token,\n          uint amountTokenDesired,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline\n      ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n      function removeLiquidity(\n          address tokenA,\n          address tokenB,\n          uint liquidity,\n          uint amountAMin,\n          uint amountBMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountA, uint amountB);\n      function removeLiquidityETH(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountToken, uint amountETH);\n      function removeLiquidityWithPermit(\n          address tokenA,\n          address tokenB,\n          uint liquidity,\n          uint amountAMin,\n          uint amountBMin,\n          address to,\n          uint deadline,\n          bool approveMax, uint8 v, bytes32 r, bytes32 s\n      ) external returns (uint amountA, uint amountB);\n      function removeLiquidityETHWithPermit(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline,\n          bool approveMax, uint8 v, bytes32 r, bytes32 s\n      ) external returns (uint amountToken, uint amountETH);\n      function swapExactTokensForTokens(\n          uint amountIn,\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external returns (uint[] memory amounts);\n      function swapTokensForExactTokens(\n          uint amountOut,\n          uint amountInMax,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external returns (uint[] memory amounts);\n      function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n          external\n          payable\n          returns (uint[] memory amounts);\n      function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          external\n          returns (uint[] memory amounts);\n      function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          external\n          returns (uint[] memory amounts);\n      function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n          external\n          payable\n          returns (uint[] memory amounts);\n  \n      function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n      function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n      function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n      function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n      function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n  }\n  \n  \n  \n  // pragma solidity >=0.6.2;\n  \n  interface IUniswapV2Router02 is IUniswapV2Router01 {\n      function removeLiquidityETHSupportingFeeOnTransferTokens(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline\n      ) external returns (uint amountETH);\n      function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n          address token,\n          uint liquidity,\n          uint amountTokenMin,\n          uint amountETHMin,\n          address to,\n          uint deadline,\n          bool approveMax, uint8 v, bytes32 r, bytes32 s\n      ) external returns (uint amountETH);\n  \n      function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n          uint amountIn,\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external;\n      function swapExactETHForTokensSupportingFeeOnTransferTokens(\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external payable;\n      function swapExactTokensForETHSupportingFeeOnTransferTokens(\n          uint amountIn,\n          uint amountOutMin,\n          address[] calldata path,\n          address to,\n          uint deadline\n      ) external;\n  }\n  \n  \n  contract CoinTool is Context, IERC20, Ownable {\n      using SafeMath for uint256;\n      using Address for address;\n  \n      mapping (address => uint256) private _rOwned;\n      mapping (address => uint256) private _tOwned;\n      mapping (address => mapping (address => uint256)) private _allowances;\n  \n      mapping (address => bool) private _isExcludedFromFee;\n  \n      mapping (address => bool) private _isExcluded;\n      address[] private _excluded;\n     \n      uint256 private constant MAX = ~uint256(0);\n      uint256 private _tTotal = 1000000000 * 10**6 * 10**9;\n      uint256 private _rTotal = (MAX - (MAX % _tTotal));\n      uint256 private _tFeeTotal;\n  \n      string private _name = "CoinTool";\n      string private _symbol = "CoinTool";\n      uint8 private _decimals = 9;\n      \n      uint256 public _taxFee = 5;\n      uint256 private _previousTaxFee = _taxFee;\n      \n      uint256 public _liquidityFee = 5;\n      uint256 private _previousLiquidityFee = _liquidityFee;\n  \n      IUniswapV2Router02 public immutable uniswapV2Router;\n      address public immutable uniswapV2Pair;\n      \n      bool inSwapAndLiquify;\n      bool public swapAndLiquifyEnabled = true;\n      \n      uint256 public _maxTxAmount = 5000000 * 10**6 * 10**9;\n      uint256 private numTokensSellToAddToLiquidity = 500000 * 10**6 * 10**9;\n\n      address public routerAddress;\n      \n      event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n      event SwapAndLiquifyEnabledUpdated(bool enabled);\n      event SwapAndLiquify(\n          uint256 tokensSwapped,\n          uint256 ethReceived,\n          uint256 tokensIntoLiqudity\n      );\n      \n      modifier lockTheSwap {\n          inSwapAndLiquify = true;\n          _;\n          inSwapAndLiquify = false;\n      }\n      \n      constructor () public {\n          _rOwned[_msgSender()] = _rTotal;\n          \n          IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\n           // Create a uniswap pair for this new token\n          uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n              .createPair(address(this), _uniswapV2Router.WETH());\n  \n          // set the rest of the contract variables\n          uniswapV2Router = _uniswapV2Router;\n          \n          //exclude owner and this contract from fee\n          _isExcludedFromFee[owner()] = true;\n          _isExcludedFromFee[address(this)] = true;\n          \n          emit Transfer(address(0), _msgSender(), _tTotal);\n      }\n  \n      function name() public view returns (string memory) {\n          return _name;\n      }\n  \n      function symbol() public view returns (string memory) {\n          return _symbol;\n      }\n  \n      function decimals() public view returns (uint8) {\n          return _decimals;\n      }\n  \n      function totalSupply() public view override returns (uint256) {\n          return _tTotal;\n      }\n  \n      function balanceOf(address account) public view override returns (uint256) {\n          if (_isExcluded[account]) return _tOwned[account];\n          return tokenFromReflection(_rOwned[account]);\n      }\n  \n      function transfer(address recipient, uint256 amount) public override returns (bool) {\n          _transfer(_msgSender(), recipient, amount);\n          return true;\n      }\n  \n      function allowance(address owner, address spender) public view override returns (uint256) {\n          return _allowances[owner][spender];\n      }\n  \n      function approve(address spender, uint256 amount) public override returns (bool) {\n          _approve(_msgSender(), spender, amount);\n          return true;\n      }\n  \n      function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n          _transfer(sender, recipient, amount);\n          _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n          return true;\n      }\n  \n      function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n          _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n          return true;\n      }\n  \n      function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n          _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n          return true;\n      }\n  \n      function isExcludedFromReward(address account) public view returns (bool) {\n          return _isExcluded[account];\n      }\n  \n      function totalFees() public view returns (uint256) {\n          return _tFeeTotal;\n      }\n  \n      function deliver(uint256 tAmount) public {\n          address sender = _msgSender();\n          require(!_isExcluded[sender], "Excluded addresses cannot call this function");\n          (uint256 rAmount,,,,,) = _getValues(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _rTotal = _rTotal.sub(rAmount);\n          _tFeeTotal = _tFeeTotal.add(tAmount);\n      }\n  \n      function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n          require(tAmount <= _tTotal, "Amount must be less than supply");\n          if (!deductTransferFee) {\n              (uint256 rAmount,,,,,) = _getValues(tAmount);\n              return rAmount;\n          } else {\n              (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n              return rTransferAmount;\n          }\n      }\n  \n      function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n          require(rAmount <= _rTotal, "Amount must be less than total reflections");\n          uint256 currentRate =  _getRate();\n          return rAmount.div(currentRate);\n      }\n  \n      function excludeFromReward(address account) public onlyOwner() {\n          // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, \'We can not exclude Uniswap router.\');\n          require(!_isExcluded[account], "Account is already excluded");\n          if(_rOwned[account] > 0) {\n              _tOwned[account] = tokenFromReflection(_rOwned[account]);\n          }\n          _isExcluded[account] = true;\n          _excluded.push(account);\n      }\n  \n      function includeInReward(address account) external onlyOwner() {\n          require(_isExcluded[account], "Account is already excluded");\n          for (uint256 i = 0; i < _excluded.length; i++) {\n              if (_excluded[i] == account) {\n                  _excluded[i] = _excluded[_excluded.length - 1];\n                  _tOwned[account] = 0;\n                  _isExcluded[account] = false;\n                  _excluded.pop();\n                  break;\n              }\n          }\n      }\n          function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _tOwned[sender] = _tOwned[sender].sub(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n      \n          function excludeFromFee(address account) public onlyOwner {\n          _isExcludedFromFee[account] = true;\n      }\n      \n      function includeInFee(address account) public onlyOwner {\n          _isExcludedFromFee[account] = false;\n      }\n      \n      function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n          _taxFee = taxFee;\n      }\n      \n      function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n          _liquidityFee = liquidityFee;\n      }\n     \n      function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n          _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n              10**2\n          );\n      }\n  \n      function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n          swapAndLiquifyEnabled = _enabled;\n          emit SwapAndLiquifyEnabledUpdated(_enabled);\n      }\n      \n       //to recieve ETH from uniswapV2Router when swaping\n      receive() external payable {}\n  \n      function _reflectFee(uint256 rFee, uint256 tFee) private {\n          _rTotal = _rTotal.sub(rFee);\n          _tFeeTotal = _tFeeTotal.add(tFee);\n      }\n  \n      function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n          (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());\n          return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n      }\n  \n      function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n          uint256 tFee = calculateTaxFee(tAmount);\n          uint256 tLiquidity = calculateLiquidityFee(tAmount);\n          uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n          return (tTransferAmount, tFee, tLiquidity);\n      }\n  \n      function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n          uint256 rAmount = tAmount.mul(currentRate);\n          uint256 rFee = tFee.mul(currentRate);\n          uint256 rLiquidity = tLiquidity.mul(currentRate);\n          uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n          return (rAmount, rTransferAmount, rFee);\n      }\n  \n      function _getRate() private view returns(uint256) {\n          (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n          return rSupply.div(tSupply);\n      }\n  \n      function _getCurrentSupply() private view returns(uint256, uint256) {\n          uint256 rSupply = _rTotal;\n          uint256 tSupply = _tTotal;      \n          for (uint256 i = 0; i < _excluded.length; i++) {\n              if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n              rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n              tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n          }\n          if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n          return (rSupply, tSupply);\n      }\n      \n      function _takeLiquidity(uint256 tLiquidity) private {\n          uint256 currentRate =  _getRate();\n          uint256 rLiquidity = tLiquidity.mul(currentRate);\n          _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n          if(_isExcluded[address(this)])\n              _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n      }\n      \n      function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n          return _amount.mul(_taxFee).div(\n              10**2\n          );\n      }\n  \n      function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n          return _amount.mul(_liquidityFee).div(\n              10**2\n          );\n      }\n      \n      function removeAllFee() private {\n          if(_taxFee == 0 && _liquidityFee == 0) return;\n          \n          _previousTaxFee = _taxFee;\n          _previousLiquidityFee = _liquidityFee;\n          \n          _taxFee = 0;\n          _liquidityFee = 0;\n      }\n      \n      function restoreAllFee() private {\n          _taxFee = _previousTaxFee;\n          _liquidityFee = _previousLiquidityFee;\n      }\n      \n      function isExcludedFromFee(address account) public view returns(bool) {\n          return _isExcludedFromFee[account];\n      }\n  \n      function _approve(address owner, address spender, uint256 amount) private {\n          require(owner != address(0), "ERC20: approve from the zero address");\n          require(spender != address(0), "ERC20: approve to the zero address");\n  \n          _allowances[owner][spender] = amount;\n          emit Approval(owner, spender, amount);\n      }\n  \n      function _transfer(\n          address from,\n          address to,\n          uint256 amount\n      ) private {\n          require(from != address(0), "ERC20: transfer from the zero address");\n          require(to != address(0), "ERC20: transfer to the zero address");\n          require(amount > 0, "Transfer amount must be greater than zero");\n          if(from != owner() && to != owner())\n              require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");\n  \n          // is the token balance of this contract address over the min number of\n          // tokens that we need to initiate a swap + liquidity lock?\n          // also, don\'t get caught in a circular liquidity event.\n          // also, don\'t swap & liquify if sender is uniswap pair.\n          uint256 contractTokenBalance = balanceOf(address(this));\n          \n          if(contractTokenBalance >= _maxTxAmount)\n          {\n              contractTokenBalance = _maxTxAmount;\n          }\n          \n          bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n          if (\n              overMinTokenBalance &&\n              !inSwapAndLiquify &&\n              from != uniswapV2Pair &&\n              swapAndLiquifyEnabled\n          ) {\n              contractTokenBalance = numTokensSellToAddToLiquidity;\n              //add liquidity\n              swapAndLiquify(contractTokenBalance);\n          }\n          \n          //indicates if fee should be deducted from transfer\n          bool takeFee = true;\n          \n          //if any account belongs to _isExcludedFromFee account then remove the fee\n          if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n              takeFee = false;\n          }\n          \n          //transfer amount, it will take tax, burn, liquidity fee\n          _tokenTransfer(from,to,amount,takeFee);\n      }\n  \n      function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n          // split the contract balance into halves\n          uint256 half = contractTokenBalance.div(2);\n          uint256 otherHalf = contractTokenBalance.sub(half);\n  \n          // capture the contract\'s current ETH balance.\n          // this is so that we can capture exactly the amount of ETH that the\n          // swap creates, and not make the liquidity event include any ETH that\n          // has been manually sent to the contract\n          uint256 initialBalance = address(this).balance;\n  \n          // swap tokens for ETH\n          swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n  \n          // how much ETH did we just swap into?\n          uint256 newBalance = address(this).balance.sub(initialBalance);\n  \n          // add liquidity to uniswap\n          addLiquidity(otherHalf, newBalance);\n          \n          emit SwapAndLiquify(half, newBalance, otherHalf);\n      }\n  \n      function swapTokensForEth(uint256 tokenAmount) private {\n          // generate the uniswap pair path of token -> weth\n          address[] memory path = new address[](2);\n          path[0] = address(this);\n          path[1] = uniswapV2Router.WETH();\n  \n          _approve(address(this), address(uniswapV2Router), tokenAmount);\n  \n          // make the swap\n          uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n              tokenAmount,\n              0, // accept any amount of ETH\n              path,\n              address(this),\n              block.timestamp\n          );\n      }\n  \n      function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n          // approve token transfer to cover all possible scenarios\n          _approve(address(this), address(uniswapV2Router), tokenAmount);\n  \n          // add the liquidity\n          uniswapV2Router.addLiquidityETH{value: ethAmount}(\n              address(this),\n              tokenAmount,\n              0, // slippage is unavoidable\n              0, // slippage is unavoidable\n              owner(),\n              block.timestamp\n          );\n      }\n  \n      //this method is responsible for taking all fee, if takeFee is true\n      function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n          if(!takeFee)\n              removeAllFee();\n          \n          if (_isExcluded[sender] && !_isExcluded[recipient]) {\n              _transferFromExcluded(sender, recipient, amount);\n          } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n              _transferToExcluded(sender, recipient, amount);\n          } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n              _transferStandard(sender, recipient, amount);\n          } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n              _transferBothExcluded(sender, recipient, amount);\n          } else {\n              _transferStandard(sender, recipient, amount);\n          }\n          \n          if(!takeFee)\n              restoreAllFee();\n      }\n  \n      function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n  \n      function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n  \n      function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n          (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n          _tOwned[sender] = _tOwned[sender].sub(tAmount);\n          _rOwned[sender] = _rOwned[sender].sub(rAmount);\n          _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n          _takeLiquidity(tLiquidity);\n          _reflectFee(rFee, tFee);\n          emit Transfer(sender, recipient, tTransferAmount);\n      }\n  \n  \n      \n  \n  }'}),u=t("68e0"),d=t.n(u),c=t("52c1"),l=(t("17b9"),{components:{},inject:["onCopySuccess"],directives:{highlightjs:{deep:!0,bind:function(e,n){var t=e.querySelectorAll("code");t.forEach((function(e){n.value&&(e.textContent=n.value),d.a.highlightBlock(e)}))},componentUpdated:function(e,n){var t=e.querySelectorAll("code");t.forEach((function(e){n.value&&(e.textContent=n.value,d.a.highlightBlock(e))}))}}},props:{sourcecode:{type:String,default:o.code},title:{type:String,default:""}},data:function(){return{loading:!0,isShowDialog:!1}},computed:Object(s["a"])({},Object(c["b"])(["isPc"])),created:function(){},mounted:function(){},methods:{show:function(){var e=this;return Object(i["a"])(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:e.isShowDialog=!e.isShowDialog;case 1:case"end":return n.stop()}}),n)})))()}}}),p=l,m=(t("1a9e"),t("5d22")),f=Object(m["a"])(p,r,a,!1,null,"e4e4afbe",null);n["a"]=f.exports},"358f":function(e,n,t){"use strict";t("1ce7")},3796:function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"upload-input"},[t("input",{ref:"excel-upload-input",staticClass:"excel-upload-input",attrs:{type:"file",accept:".xlsx,.csv,.xls"},on:{change:e.handleClick}}),t("div",{staticClass:"drop",on:{drop:e.handleDrop,dragover:e.handleDragover,dragenter:e.handleDragover,click:e.handleUpload}},[e._m(0),t("p",[e._v(e._s(e.$t("common.upload_text")))])])])},a=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[t("i",{staticClass:"el-icon-upload2 icon"})])}],i=(t("7479"),t("37de"),t("22f9"),t("65f0"),t("dfe9"),t("3f81")),s=t.n(i),o={props:{beforeUpload:Function,onSuccess:Function},data:function(){return{loading:!1,excelData:{header:null,results:null}}},methods:{generateData:function(e){var n=e.header,t=e.results;this.excelData.header=n,this.excelData.results=t,this.onSuccess&&this.onSuccess(this.excelData)},handleDrop:function(e){if(e.stopPropagation(),e.preventDefault(),!this.loading){var n=e.dataTransfer.files;if(1===n.length){var t=n[0];if(!this.isExcel(t))return this.$message.error("Only supports upload .xlsx, .xls, .csv suffix files"),!1;this.upload(t),e.stopPropagation(),e.preventDefault()}else this.$message.error("Only support uploading one file!")}},handleDragover:function(e){e.stopPropagation(),e.preventDefault(),e.dataTransfer.dropEffect="copy"},handleUpload:function(){this.$refs["excel-upload-input"].click()},handleClick:function(e){var n=e.target.files,t=n[0];t&&this.upload(t)},upload:function(e){if(this.$refs["excel-upload-input"].value=null,this.beforeUpload){var n=this.beforeUpload(e);n&&this.readerData(e)}else this.readerData(e)},readerData:function(e){var n=this;return this.loading=!0,new Promise((function(t,r){var a=new FileReader;a.onload=function(e){var r=e.target.result,a=s.a.read(r,{type:"array"}),i=a.SheetNames[0],o=a.Sheets[i];try{var u=!1,d={},c={},l=o["!ref"].split(":")[1].split("B")[1],p=JSON.parse(JSON.stringify(o));for(var m in p){if("A1"===m){try{p[m].w.length>=40&&(d=o[m],u=!0,p[m].t="s",p[m].v="Address",p[m].w="Address")}catch(_){p[m].v.length>=40&&(d=o[m],u=!0,p[m].t="s",p[m].v="Address",p[m].w="Address")}"Address"!==p[m].w&&(p[m].t="s",p[m].v="Address",p[m].w="Address")}"B1"===m&&(!u&&isNaN(Number(p[m].w))||(c=o[m],p[m].t="s",p[m].v="Address",p[m].w="Address"),"Amount"!==p[m].w&&(p[m].t="s",p[m].v="Amount",p[m].w="Amount"))}if(u){var f="A"+(parseInt(l)+1),h="B"+(parseInt(l)+1);p[f]=d,p[h]=c,p["!ref"]="A1:"+h}o=p}catch(_){console.log(_)}var w=n.getHeaderRow(o),v=s.a.utils.sheet_to_json(o,{raw:!1,header:0});n.generateData({header:w,results:v}),n.loading=!1,t()},a.readAsArrayBuffer(e)}))},getHeaderRow:function(e){var n,t=[],r=s.a.utils.decode_range(e["!ref"]),a=r.s.r;for(n=r.s.c;n<=r.e.c;++n){var i=e[s.a.utils.encode_cell({c:n,r:a})],o="UNKNOWN "+n;i&&i.t&&(o=s.a.utils.format_cell(i)),t.push(o)}return t},isExcel:function(e){return/\.(xlsx|xls|csv|txt)$/.test(e.name)}}},u=o,d=(t("358f"),t("5d22")),c=Object(d["a"])(u,r,a,!1,null,"a04ccbf4",null);n["a"]=c.exports},"38c8":function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("el-select",{staticStyle:{width:"100%"},attrs:{loading:e.loading_address,clearable:"","default-first-option":"","allow-create":"",placeholder:"e.g. 0x111111111111111",filterable:"","filter-method":e.handleFilterAddress},model:{value:e.address,callback:function(n){e.address=n},expression:"address"}},e._l(e.selectOptions,(function(n){return t("el-option",{key:n.value,attrs:{label:n.label,value:n.value}},[t("span",{staticStyle:{float:"left"}},[e._v(e._s(e._f("autoAddress")(n.value)))]),e.tokenNameif(n.value,n.label).indexOf("Token")>=0?t("span",{staticStyle:{float:"right",color:"red","font-size":"13px"}},[e._v(e._s(e.tokenNameif(n.value,n.label)))]):t("span",{staticStyle:{float:"right",color:"#8492a6","font-size":"13px"}},[e._v(e._s(e.tokenNameif(n.value,n.label)))])])})),1)},a=[],i=t("4833"),s=t("efe2"),o=(t("6a61"),t("37de"),t("1e34"),t("dfe9"),t("96e6"),t("fdea"),t("7479"),t("4a32"),t("403f"),t("8b79"),t("65f0"),t("297b"),t("9bdd"),t("52c1")),u=t("a835"),d=t("4672"),c=t.n(d),l=t("7742"),p=t.n(l),m=t("b893"),f=t("8feb"),h=t.n(f),w={inject:["onCheckConnect"],components:{},props:{pairAddress:{require:!0,type:String,default:""}},data:function(){return{address:"",chainName:"",loading_address:!1,selectOptions:[],addressOptionsCopy:[]}},computed:Object(s["a"])(Object(s["a"])({},Object(o["b"])(["isConnect","account","isPc","language"])),{},{selectAddressList:function(){return this.$store.state.eth.selectAddressList}}),watch:{address:function(e){this.$emit("update:pairAddress",e)},account:{immediate:!0,handler:function(e){""!==e&&this.tokenGet()}}},created:function(){this.address=this.pairAddress,this.chainName=this.$route.path.replace("/".concat(this.$route.name,"/"),"").replace("/","")},mounted:function(){},methods:{tokenNameif:function(e,n){switch(n){case"UNI-V2":return"Uniswap Liquidity LP";case"Cake-LP":return"Pancake Liquidity LP";default:return"LP"===n.substr(-2,2)||"lp"===n.substr(-2,2)?"Liquidity LP":"Token "+n}},handleFilterAddress:function(e){var n=this;return Object(i["a"])(regeneratorRuntime.mark((function t(){var r,a;return regeneratorRuntime.wrap((function(t){while(1)switch(t.prev=t.next){case 0:if(e=e.trim(),n.selectOptions=e?n.selectOptions.filter((function(n){if(~n.label.indexOf(e)||~n.label.toUpperCase().indexOf(e.toUpperCase())||~n.value.indexOf(e)||~n.value.toUpperCase().indexOf(e.toUpperCase()))return!0})):n.addressOptionsCopy,n.onCheckConnect()){t.next=4;break}return t.abrupt("return");case 4:if(40!==e.length&&42!==e.length){t.next=28;break}if(n.loading_address=!0,40===e.length&&(e="0x"+e),c.a.isValidAddress(e)){t.next=11;break}return n.$message.error("Token Address Error1"),n.loading_address=!1,t.abrupt("return");case 11:return t.prev=11,r={to:e,data:"0x"+p.a.methodID("symbol",[]).toString("hex")},t.next=15,u["a"].sendEthcall(r);case 15:if(a=t.sent,"0x"!==a){t.next=20;break}return n.$message.error("Token Address Error"),n.loading_address=!1,t.abrupt("return");case 20:n.selectOptions.push({value:e,label:m["a"].cleanAsciiText(h.a.toAscii(a).toString())}),n.address=e,t.next=27;break;case 24:t.prev=24,t.t0=t["catch"](11),n.$message.error("Token Address Error");case 27:n.loading_address=!1;case 28:case"end":return t.stop()}}),t,null,[[11,24]])})))()},tokenGet:function(){var e=this;return Object(i["a"])(regeneratorRuntime.mark((function n(){var t,r,a,i,s,o,d,c,l,p,m,f,h,w,v,_,b;return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:if(0===e.selectAddressList.length){n.next=5;break}return console.log("get Cache"),e.selectOptions=e.selectAddressList,e.addressOptionsCopy=e.selectAddressList,n.abrupt("return");case 5:if(t=[128],r=[1,250,137,56],a=[66],i=[],n.prev=9,e.loading_address=!0,!r.includes(u["a"].getChainId())){n.next=25;break}return s="https://api.covalenthq.com/v1/".concat(u["a"].getChainId(),"/address/").concat(u["a"].getAccount(),"/balances_v2/?no-nft-fetch=true&key=ckey_fdf13a80f62d428cbe85ae4bb16"),n.next=15,e.$ajax({url:s,method:"get"});case 15:o=n.sent,d=o.data.items,n.t0=regeneratorRuntime.keys(d);case 18:if((n.t1=n.t0()).done){n.next=25;break}if(c=n.t1.value,0!==Number(d[c].balance)){n.next=22;break}return n.abrupt("continue",18);case 22:i.push({label:d[c].contract_ticker_symbol,value:d[c].contract_address}),n.next=18;break;case 25:if(!t.includes(u["a"].getChainId())){n.next=33;break}return l=u["a"].chainIdToChainName(u["a"].getChainId()),p=e.$coinInfo[l].blockBrowser.replace("https://",""),n.next=30,e.$ajax({url:"https://token-scan.glitch.me/?platform=".concat(p,"&address=").concat(u["a"].getAccount()),method:"get"});case 30:for(h in m=n.sent,f=m,f)i.push({label:f[h].symbol,value:f[h].tokenAddress});case 33:if(!a.includes(u["a"].getChainId())){n.next=40;break}return w="https://www.oklink.com/api/explorer/v1/okexchain/transactions/types/".concat(u["a"].getAccount(),"?t=1629005146286&type=oip20Balance"),n.next=37,e.$ajax({url:"https://proxy.cointool.workers.dev/?url=".concat(encodeURIComponent(w)),method:"get"});case 37:for(b in v=n.sent,_=v.data,_)i.push({label:_[b].tokenSymbol,value:_[b].tokenAddress});case 40:n.next=45;break;case 42:n.prev=42,n.t2=n["catch"](9),console.log(n.t2);case 45:e.loading_address=!1,e.selectOptions=i,e.addressOptionsCopy=i,e.$store.dispatch("eth/changeSelectAddressList",i);case 49:case"end":return n.stop()}}),n,null,[[9,42]])})))()}}},v=w,_=t("5d22"),b=Object(_["a"])(v,r,a,!1,null,"218db75f",null);n["a"]=b.exports},"3d65":function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return e.isShowDaBox&&!e.isIframe?t("div",{staticClass:"daBox",on:{click:e.onGo}},[t("div",{staticClass:"content"},[t("h3",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/c0deCn/wiki@master/logo.png"}}),e._v(" "+e._s(e.$t("route.multiSender"))+" ")]),e._m(0)]),t("div",{staticClass:"closeBtn"},[t("i",{staticClass:"el-icon-close",on:{click:function(n){n.stopPropagation(),e.isShowDaBox=!1}}})])]):e._e()},a=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[t("span",{staticClass:"label"},[e._v("Network supports:")]),t("span",{staticClass:"network"},[e._v("ETH BSC HECO DOT TRX ...")])])}],i=t("efe2"),s=(t("5502"),t("37de"),t("1e34"),t("dfe9"),t("403f"),t("297b"),t("52c1")),o={data:function(){return{isShowDaBox:!0,isIframe:!1}},computed:Object(i["a"])({},Object(s["b"])(["isPc"])),mounted:function(){},created:function(){var e=this.$route.query.iframe;e&&(this.isIframe=!0)},methods:{onGo:function(){var e=Object.keys(this.$coinInfo),n=this.$route.path.replace("/".concat(this.$route.name,"/"),"").replace("/","");e.includes(n)||(n="eth"),this.$router.push({path:"/multiSender/".concat(n)})}}},u=o,d=(t("24b4"),t("5d22")),c=Object(d["a"])(u,r,a,!1,null,"4f0f37e5",null);n["a"]=c.exports},"655a":function(e,n,t){},73688:function(e,n,t){"use strict";t("0e80")},"745c":function(e,n,t){},"750f":function(e,n,t){"use strict";t("1dab")},7691:function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"tabDiv"},[t("ul",{staticClass:"tabs"},e._l(e.list,(function(n){return t("li",{key:n.value,class:{on:e.active===n.value},on:{click:function(t){return e.onChangeCreateTokenActive(n.value)}}},[e._v(e._s(n.label))])})),0)])},a=[],i=(t("65f0"),{name:"CreateTokenTab",components:{},props:{list:{type:Array,default:function(){return[]}},active:{type:[Number,String],require:!0}},data:function(){return{}},methods:{onChangeCreateTokenActive:function(e){this.$emit("onChangeCreateTokenActive",e)}}}),s=i,o=(t("0061"),t("5d22")),u=Object(o["a"])(s,r,a,!1,null,"4ed7193a",null);n["a"]=u.exports},"7dc2":function(e,n,t){"use strict";t("fba4")},"850d":function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"headerBox"},[t("div",{staticClass:"headerBg"},[t("h2",[e._v(e._s(e.title)+" "),t("i",{staticClass:"el-icon-question tutorial",on:{click:e.onLinkTutorial}})]),t("ul",{staticClass:"supportBox"},e._l(e.supportNetworks,(function(n){return t("li",{key:n.name,on:{click:function(t){return e.onChangeNetwork(n)}}},[t("div",{staticClass:"iconBox"},[t("svg-icon",{staticClass:"icon",attrs:{"icon-class":n.icon}})],1),t("span",{staticClass:"name"},[e._v(e._s(n.name))])])})),0)])])},a=[],i=t("4833"),s=(t("6a61"),t("a835")),o={name:"OneToMoreHeader",props:{supportNetworks:{default:function(){return[]},type:Array},title:{default:"",type:String}},data:function(){return{}},created:function(){},methods:{onChangeNetwork:function(e){return Object(i["a"])(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:n.t0=e.icon,n.next="coin-heco"===n.t0?3:"coin-ftm"===n.t0?5:"coin-bnb"===n.t0?7:"coin-okex"===n.t0?9:"coin-matic"===n.t0?11:13;break;case 3:return s["a"].addToMetamask(128),n.abrupt("return",!1);case 5:return s["a"].addToMetamask(250),n.abrupt("return",!1);case 7:return s["a"].addToMetamask(56),n.abrupt("return",!1);case 9:return s["a"].addToMetamask(66),n.abrupt("return",!1);case 11:return s["a"].addToMetamask(137),n.abrupt("return",!1);case 13:case"end":return n.stop()}}),n)})))()},onLinkTutorial:function(){this.$router.push({name:"doc",query:{tab:"multiSender"}})}}},u=o,d=(t("73688"),t("5d22")),c=Object(d["a"])(u,r,a,!1,null,"c3ab1ad4",null);n["a"]=c.exports},8596:function(e,n,t){"use strict";t("0455")},b6ed:function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{directives:[{name:"show",rawName:"v-show",value:e.isShow&&""!==e.account&&e.trueChainName!==e.chainName&&"eth"!==e.chainName&&!1===e.isIframe,expression:"isShow && account !== '' && trueChainName !== chainName && chainName !== 'eth' && isIframe === false"}],staticClass:"networkError"},[e._m(0),t("p",{staticClass:"desc"},[e._v(e._s(e.$t("networkError.network_error",{chainName:e.chainName.toUpperCase()})))]),e.isPc?e._e():t("p",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],staticClass:"desc1"},[t("span",[e._v(e._s(e.$t("networkError.metamask_add_network")))]),e.isPc||1!==e.walletType?e._e():t("el-button",{attrs:{size:"mini",type:"danger",plain:""},on:{click:e.onYoutube}},[t("svg-icon",{staticClass:"icon",attrs:{"icon-class":"youtube"}}),e._v("Youtube")],1)],1),t("div",{staticClass:"btnBox"},[e.isPc?t("el-button",{attrs:{size:"mini",type:"success",plain:""},on:{click:e.onChangeNetwork}},[e._v(e._s(e.$t("networkError.switch_network",{chainName:e.chainName.toUpperCase()})))]):e._e(),t("el-button",{attrs:{size:"mini",type:"success",plain:""},on:{click:e.onChangePage}},[e._v(e._s(e.$t("networkError.switch_page")))])],1),t("div",{staticClass:"close"},[t("i",{staticClass:"el-icon-close",on:{click:function(n){e.isShow=!1}}})]),t("div",{staticClass:"metamask"},[t("svg-icon",{staticClass:"icon",attrs:{"icon-class":"metamask"}})],1)])},a=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("h5",{staticClass:"title"},[t("i",{staticClass:"el-icon-warning icon"}),t("span",[e._v("Warning")])])}],i=t("4833"),s=t("efe2"),o=(t("6a61"),t("37de"),t("1e34"),t("dfe9"),t("8b79"),{zh:{networkError:{switch_network:"切换到{chainName}网络",switch_network_error:"你当前使用的 DAPP浏览器不支持该功能",switch_page:"切换到当前网络页面",network_error:"网络错误，请切换到 {chainName} 网络",metamask_add_network:"MetaMask如何添加App上的网络？"}},en:{networkError:{switch_network:"Switch to {chainName} network",switch_network_error:"Your current DApp browser does not support this feature",switch_page:"Switch to the current network page",network_error:"Network error, please switch to {chainName}",metamask_add_network:"How does MetaMask add a network on the App?"}}}),u=t("a835"),d=t("52c1"),c="networkError",l={data:function(){return{isShow:!0,isIframe:!1,chainName:""}},computed:Object(s["a"])(Object(s["a"])({},Object(d["b"])(["isPc","account","walletType","chainId"])),{},{trueChainName:function(){return u["a"].chainIdToChainName(parseInt(this.chainId))}}),created:function(){this.$i18n.getLocaleMessage("en")[c]||(this.$i18n.mergeLocaleMessage("en",o.en),this.$i18n.mergeLocaleMessage("zh",o.zh));var e=this.$route.query.iframe;e&&(this.isIframe=!0),this.chainName=this.$route.path.replace("/".concat(this.$route.name,"/"),"").replace("/","")},mounted:function(){},methods:{onYoutube:function(){window.open("https://www.youtube.com/watch?v=2v742XwyMEI","_blank")},onChangeNetwork:function(){var e=this;return Object(i["a"])(regeneratorRuntime.mark((function n(){var t;return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:return n.next=2,u["a"].addToMetamask(e.$coinInfo[e.chainName].chainId);case 2:t=n.sent,t||e.$message.error(e.$t("networkError.switch_network_error"));case 4:case"end":return n.stop()}}),n)})))()},onChangePage:function(){this.$coinInfo[this.chainName].chainId!==parseInt(this.chainId)&&this.$router.replace({path:"/".concat(this.$route.name,"/").concat(this.trueChainName),query:this.$route.query}),console.log("chainId",parseInt(this.chainId))}}},p=l,m=(t("750f"),t("5d22")),f=Object(m["a"])(p,r,a,!1,null,"6b88e5e8",null);n["a"]=f.exports},fa7e:function(e,n,t){"use strict";var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"editor"},[t("textarea",{ref:"textarea",attrs:{placeholder:e.placeholder}})])},a=[],i=t("012b"),s=t.n(i),o=(t("dcf6"),t("e5d4"),t("f3f2"),t("ab82"),{name:"JsonEditor",props:{placeholder:{type:String,required:!0},value:{type:[String,Array],required:!0}},data:function(){return{jsonEditor:!1}},watch:{value:function(e){var n=this.jsonEditor.getValue();e!==n&&this.jsonEditor.setValue(e)}},mounted:function(){var e=this;this.jsonEditor=s.a.fromTextArea(this.$refs.textarea,{lineNumbers:!0,mode:"string",theme:"idea",styleActiveLine:!0,lint:!0}),this.jsonEditor.setValue(this.value),this.jsonEditor.on("change",(function(n){e.$emit("changed",n.getValue()),e.$emit("input",n.getValue())}))},methods:{getValue:function(){return this.jsonEditor.getValue()}}}),u=o,d=(t("8596"),t("5d22")),c=Object(d["a"])(u,r,a,!1,null,"71049d4e",null);n["a"]=c.exports},fba4:function(e,n,t){},ff09:function(e,n,t){"use strict";t("18ac")}}]);